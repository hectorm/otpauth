{"version":3,"sources":["webpack:/// [synthetic:base] ","webpack:/// [synthetic:util/global] ","webpack:///webpack/universalModuleDefinition","webpack:///otpauth.js","webpack:///webpack/bootstrap a3d1767cf7cd9b7840d2","webpack:///./src/Utils.js","webpack:///./src/Secret.js","webpack:///./src/HMAC.js","webpack:///./src/OTP.js","webpack:///./src/URI.js","webpack:///external \"crypto\"","webpack:///(webpack)/buildin/global.js","webpack:///./src/.sjcl.custom.js"],"names":["__WEBPACK_EXTERNAL_MODULE_5__","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","__webpack_require__.i","value","d","__webpack_require__.d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__webpack_require__.n","__esModule","getDefault","getModuleExports","__webpack_require__.o","object","property","prototype","hasOwnProperty","p","s","Utils","uint","decode","buff","tArr","Uint8Array","num","length","encode","ArrayBuffer","acc","raw","String","fromCharCode","apply","str","charCodeAt","b32","bits","alphabet","strU","toUpperCase","index","idx","indexOf","Error","hex","hexByte","toString","parseInt","substr","global","constructor","Secret","buffer","getRandomBytes","__WEBPACK_IMPORTED_MODULE_1__Utils_js__","__WEBPACK_IMPORTED_MODULE_0_crypto__","__WEBPACK_IMPORTED_MODULE_0_crypto___default","size","a","randomBytes","bytes","crypto","getRandomValues","msCrypto","Math","floor","random","HMAC","__WEBPACK_IMPORTED_MODULE_1__sjcl_custom_js__","__WEBPACK_IMPORTED_MODULE_1__sjcl_custom_js___default","HMAC_ALGORITHMS","digest","algorithm","createHmac","hmac","key","update","message","hash","fromBits","codec","arrayBuffer","toBits","misc","TOTP","issuer","label","secret","__WEBPACK_IMPORTED_MODULE_1__Secret_js__","digits","period","HOTP","counter","__WEBPACK_IMPORTED_MODULE_0__Utils_js__","__WEBPACK_IMPORTED_MODULE_2__HMAC_js__","__WEBPACK_IMPORTED_MODULE_3__URI_js__","generate","pad","offset","byteLength","binary","pow","Array","join","validate","window","searchToken","token","generatedToken","stringify","timestamp","Date","now","URI","__WEBPACK_IMPORTED_MODULE_2__OTP_js__","OTPURI_REGEX","SECRET_REGEX","ALGORITHM_REGEX","INTEGER_REGEX","POSITIVE_INTEGER_REGEX","parse","uri","uriGroups","decodeURIComponent","match","uriType","toLowerCase","uriLabel","split","uriParams","reduce","cur","pairArr","pairKey","pairVal","otpObj","otpCfg","test","otp","encodeURI","g","Function","eval","e","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","sjcl","cipher","keyexchange","mode","exception","corrupt","this.toString","invalid","bug","notReady","bitSlice","bstart","bend","bitArray","_shiftRight","slice","undefined","clamp","extract","blength","sh","x","concat","a1","a2","last","shift","getPartial","bitLength","len","ceil","partial","_end","round","equal","b","carry","out","push","shift2","last2","pop","_xor4","y","byteswapM","v","globals","globals.ArrayBuffer","DataView","globals.DataView","arr","padding","padding_count","ol","tmp","setUint32","smallest","setUint8","getUint8","inView","getUint32","hexDumpBuffer","stringBufferView","string","getUint16","width","console","log","sha1","sjcl.hash.sha1","_h","_buffer","_length","reset","sjcl.hash.sha1.hash","data","finalize","blockSize","_init","utf8String","nl","Uint32Array","j","_block","subarray","splice","h","_key","_f","t","_S","words","w","sha256","sjcl.hash.sha256","_precompute","sjcl.hash.sha256.hash","frac","prime","factor","isPrime","k","h0","h1","h2","h3","h4","h5","h6","h7","sha512","sjcl.hash.sha512","sjcl.hash.sha512.hash","_initr","_keyr","frac2","wrh","wrl","h0h","h0l","h1h","h1l","h2h","h2l","h3h","h3l","h4h","h4l","h5h","h5l","h6h","h6l","h7h","h7l","ah","al","bh","bl","ch","cl","dh","dl","eh","el","fh","fl","gh","gl","hh","hl","gamma0xh","gamma0xl","gamma0h","gamma0l","gamma1xh","gamma1xl","gamma1h","gamma1l","wr7h","wr16h","wr16l","wr7l","chh","chl","majh","majl","sigma0h","sigma0l","krh","krl","t1l","t1h","t2l","t2h","sjcl.misc.hmac","Hash","_hash","exKey","bs","_baseHash","_resultHash","encrypt","mac","sjcl.misc.hmac.prototype.mac","_updated","sjcl.misc.hmac.prototype.reset","sjcl.misc.hmac.prototype.update","sjcl.misc.hmac.prototype.digest","result","__WEBPACK_IMPORTED_MODULE_3__OTP_js__","__WEBPACK_IMPORTED_MODULE_4__URI_js__","factory","require","define","amd","root"],"mappings":"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","file":"otpauth.js","sourcesContent":["null\n\n\n// WEBPACK FOOTER //\n//  [synthetic:base] ","null\n\n\n// WEBPACK FOOTER //\n//  [synthetic:util/global] ","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"crypto\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"crypto\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OTPAuth\"] = factory(require(\"crypto\"));\n\telse\n\t\troot[\"OTPAuth\"] = factory(root[\"crypto\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"crypto\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"crypto\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OTPAuth\"] = factory(require(\"crypto\"));\n\telse\n\t\troot[\"OTPAuth\"] = factory(root[\"crypto\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * @class Utils\n */\nclass Utils {\n\t/**\n\t * @type {Object}\n\t */\n\tstatic get uint() {\n\t\t/**\n\t\t * Converts an ArrayBuffer to an integer.\n\t\t * @memberof Utils.uint\n\t\t * @method decode\n\t\t * @param {ArrayBuffer} buff ArrayBuffer.\n\t\t * @returns {number} Integer.\n\t\t */\n\t\tconst decode = function (buff) {\n\t\t\tconst tArr = new Uint8Array(buff);\n\t\t\tlet num = 0;\n\n\t\t\tfor (let i = 0; i < tArr.length; i++) {\n\t\t\t\tif (tArr[i] === 0) continue;\n\t\t\t\tnum *= 256;\n\t\t\t\tnum += tArr[i];\n\t\t\t}\n\n\t\t\treturn num;\n\t\t};\n\n\t\t/**\n\t\t * Converts an integer to an ArrayBuffer.\n\t\t * @memberof Utils.uint\n\t\t * @method encode\n\t\t * @param {string} num Integer.\n\t\t * @returns {ArrayBuffer} ArrayBuffer.\n\t\t */\n\t\tconst encode = function (num) {\n\t\t\tconst buff = new ArrayBuffer(8);\n\t\t\tconst tArr = new Uint8Array(buff);\n\t\t\tlet acc = num;\n\n\t\t\tfor (let i = 7; i >= 0; i--) {\n\t\t\t\tif (acc === 0) break;\n\t\t\t\ttArr[i] = acc & 255;\n\t\t\t\tacc -= tArr[i];\n\t\t\t\tacc /= 256;\n\t\t\t}\n\n\t\t\treturn buff;\n\t\t};\n\n\t\treturn {decode, encode};\n\t}\n\n\t/**\n\t * @type {Object}\n\t */\n\tstatic get raw() {\n\t\t/**\n\t\t * Converts an ArrayBuffer to a string.\n\t\t * @memberof Utils.raw\n\t\t * @method decode\n\t\t * @param {ArrayBuffer} buff ArrayBuffer.\n\t\t * @returns {string} String.\n\t\t */\n\t\tconst decode = function (buff) {\n\t\t\treturn String.fromCharCode.apply(null, new Uint8Array(buff));\n\t\t};\n\n\t\t/**\n\t\t * Converts a string to an ArrayBuffer.\n\t\t * @memberof Utils.raw\n\t\t * @method encode\n\t\t * @param {string} str String.\n\t\t * @returns {ArrayBuffer} ArrayBuffer.\n\t\t */\n\t\tconst encode = function (str) {\n\t\t\tconst buff = new ArrayBuffer(str.length);\n\t\t\tconst tArr = new Uint8Array(buff);\n\n\t\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\t\ttArr[i] = str.charCodeAt(i);\n\t\t\t}\n\n\t\t\treturn buff;\n\t\t};\n\n\t\treturn {decode, encode};\n\t}\n\n\t/**\n\t * @type {Object}\n\t */\n\tstatic get b32() {\n\t\t// RFC 4648 base32 alphabet without pad\n\t\tconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n\n\t\t/**\n\t\t * Converts an ArrayBuffer to a base32 string (RFC 4648).\n\t\t * @see https://tools.ietf.org/html/rfc4648\n\t\t * @see https://github.com/LinusU/base32-decode\n\t\t * @memberof Utils.b32\n\t\t * @method decode\n\t\t * @param {ArrayBuffer} buff ArrayBuffer.\n\t\t * @returns {string} Base32 string.\n\t\t */\n\t\tconst decode = function (buff) {\n\t\t\t// Based on LinusU/base32-decode\n\t\t\tconst tArr = new Uint8Array(buff);\n\t\t\tlet bits = 0, value = 0, str = '';\n\n\t\t\tfor (let i = 0; i < tArr.length; i++) {\n\t\t\t\tvalue = value << 8 | tArr[i];\n\t\t\t\tbits += 8;\n\n\t\t\t\twhile (bits >= 5) {\n\t\t\t\t\tstr += alphabet[value >>> bits - 5 & 31];\n\t\t\t\t\tbits -= 5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bits > 0) {\n\t\t\t\tstr += alphabet[value << 5 - bits & 31];\n\t\t\t}\n\n\t\t\treturn str;\n\t\t};\n\n\t\t/**\n\t\t * Converts a base32 string to an ArrayBuffer (RFC 4648).\n\t\t * @see https://tools.ietf.org/html/rfc4648\n\t\t * @see https://github.com/LinusU/base32-encode\n\t\t * @memberof Utils.b32\n\t\t * @method encode\n\t\t * @param {string} str Base32 String.\n\t\t * @returns {ArrayBuffer} ArrayBuffer.\n\t\t */\n\t\tconst encode = function (str) {\n\t\t\t// Based on LinusU/base32-encode\n\t\t\tconst strU = str.toUpperCase();\n\t\t\tconst buff = new ArrayBuffer(str.length * 5 / 8 | 0);\n\t\t\tconst tArr = new Uint8Array(buff);\n\t\t\tlet bits = 0, value = 0, index = 0;\n\n\t\t\tfor (let i = 0; i < strU.length; i++) {\n\t\t\t\tlet idx = alphabet.indexOf(strU[i]);\n\n\t\t\t\tif (idx === -1) {\n\t\t\t\t\tthrow new Error('Invalid character found: ' + strU[i]);\n\t\t\t\t}\n\n\t\t\t\tvalue = value << 5 | idx;\n\t\t\t\tbits += 5;\n\n\t\t\t\tif (bits >= 8) {\n\t\t\t\t\ttArr[index++] = value >>> bits - 8 & 255;\n\t\t\t\t\tbits -= 8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn buff;\n\t\t};\n\n\t\treturn {decode, encode};\n\t}\n\n\t/**\n\t * @type {Object}\n\t */\n\tstatic get hex() {\n\t\t/**\n\t\t * Converts an ArrayBuffer to a hexadecimal string.\n\t\t * @memberof Utils.hex\n\t\t * @method decode\n\t\t * @param {ArrayBuffer} buff ArrayBuffer.\n\t\t * @returns {string} Hexadecimal string.\n\t\t */\n\t\tconst decode = function (buff) {\n\t\t\tconst tArr = new Uint8Array(buff);\n\t\t\tlet str = '';\n\n\t\t\tfor (let i = 0; i < tArr.length; i++) {\n\t\t\t\tconst hexByte = tArr[i].toString(16);\n\n\t\t\t\tstr += hexByte.length === 1\n\t\t\t\t\t? '0' + hexByte\n\t\t\t\t\t: hexByte;\n\t\t\t}\n\n\t\t\treturn str.toUpperCase();\n\t\t};\n\n\t\t/**\n\t\t * Converts a hexadecimal string to an ArrayBuffer.\n\t\t * @memberof Utils.hex\n\t\t * @method encode\n\t\t * @param {string} str Hexadecimal string.\n\t\t * @returns {ArrayBuffer} ArrayBuffer.\n\t\t */\n\t\tconst encode = function (str) {\n\t\t\tconst buff = new ArrayBuffer(str.length / 2);\n\t\t\tconst tArr = new Uint8Array(buff);\n\n\t\t\tfor (let i = 0; i < tArr.length; i++) {\n\t\t\t\ttArr[i] = parseInt(str.substr(i * 2, 2), 16);\n\t\t\t}\n\n\t\t\treturn buff;\n\t\t};\n\n\t\treturn {decode, encode};\n\t}\n}\n/* harmony export (immutable) */ exports[\"a\"] = Utils;\n\n\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_crypto__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_crypto___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_crypto__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_js__ = __webpack_require__(0);\n\n\n\n\n\n/**\n * @class Secret\n */\nclass Secret {\n\t/**\n\t * Secret key object.\n\t * @param {Object} [config] Configuration options.\n\t * @param {ArrayBuffer} [config.buffer=Secret.getRandomBytes] ArrayBuffer of the secret key.\n\t */\n\tconstructor({buffer} = {}) {\n\t\t/** @type {ArrayBuffer} */\n\t\tthis.buffer = typeof buffer === 'undefined'\n\t\t\t? this.buffer = Secret.getRandomBytes()\n\t\t\t: buffer;\n\t\t/** @type {string} */\n\t\tthis.raw = __WEBPACK_IMPORTED_MODULE_1__Utils_js__[\"a\" /* Utils */].raw.decode(this.buffer);\n\t\t/** @type {string} */\n\t\tthis.b32 = __WEBPACK_IMPORTED_MODULE_1__Utils_js__[\"a\" /* Utils */].b32.decode(this.buffer);\n\t\t/** @type {string} */\n\t\tthis.hex = __WEBPACK_IMPORTED_MODULE_1__Utils_js__[\"a\" /* Utils */].hex.decode(this.buffer);\n\t}\n\n\t/**\n\t * Returns an ArrayBuffer of random bytes using Node or Web Cryptography API.\n\t * @method getRandomBytes\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.size=20] Number of bytes to generate.\n\t * @returns {ArrayBuffer} Random bytes.\n\t */\n\tstatic getRandomBytes({size = 20} = {}) {\n\t\tlet bytes;\n\n\t\tif (typeof __WEBPACK_IMPORTED_MODULE_0_crypto___default.a !== 'undefined' && typeof __WEBPACK_IMPORTED_MODULE_0_crypto___default.a.randomBytes !== 'undefined') {\n\t\t\tbytes = new Uint8Array(__WEBPACK_IMPORTED_MODULE_0_crypto___default.a.randomBytes(size).buffer, 0, size);\n\t\t} else {\n\t\t\tbytes = new Uint8Array(size);\n\n\t\t\tif (typeof global.crypto !== 'undefined' && typeof global.crypto.getRandomValues !== 'undefined') {\n\t\t\t\tglobal.crypto.getRandomValues(bytes);\n\t\t\t} else if (typeof global.msCrypto !== 'undefined' && typeof global.msCrypto.getRandomValues !== 'undefined') {\n\t\t\t\tglobal.msCrypto.getRandomValues(bytes);\n\t\t\t} else { // WARNING: 'Math.random' is not cryptographically-secure\n\t\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\t\tbytes[i] = Math.floor(Math.random() * 256);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn bytes.buffer;\n\t}\n}\n/* harmony export (immutable) */ exports[\"a\"] = Secret;\n\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_crypto__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_crypto___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_crypto__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sjcl_custom_js__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sjcl_custom_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__sjcl_custom_js__);\n\n\n\n\n\n/**\n * Supported HMAC algorithms.\n * The value of each key is used by the Stanford Javascript Crypto Library (SJCL).\n * @private\n */\nconst HMAC_ALGORITHMS = {\n\t'SHA1': 'sha1',\n\t'SHA256': 'sha256',\n\t'SHA512': 'sha512'\n};\n\n/**\n * @class HMAC\n */\nclass HMAC {\n\t/**\n\t * Calculates the HMAC digest of the given key and message.\n\t * @method digest\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.algorithm Hashing algorithm (SHA1, SHA256 or SHA512).\n\t * @param {ArrayBuffer} config.key Key.\n\t * @param {ArrayBuffer} config.message Message.\n\t * @returns {ArrayBuffer} Digest.\n\t */\n\tstatic digest({algorithm, key, message}) {\n\t\tif (!(algorithm in HMAC_ALGORITHMS)) {\n\t\t\tthrow Error('Unknown hash function');\n\t\t}\n\n\t\tlet digest;\n\n\t\tif (typeof __WEBPACK_IMPORTED_MODULE_0_crypto___default.a !== 'undefined' && typeof __WEBPACK_IMPORTED_MODULE_0_crypto___default.a.createHmac !== 'undefined') {\n\t\t\tconst hmac = __WEBPACK_IMPORTED_MODULE_0_crypto___default.a.createHmac(algorithm, new Uint8Array(key));\n\t\t\thmac.update(new Uint8Array(message));\n\n\t\t\tdigest = hmac.digest();\n\t\t} else if (typeof __WEBPACK_IMPORTED_MODULE_1__sjcl_custom_js___default.a !== 'undefined') {\n\t\t\tconst hash = __WEBPACK_IMPORTED_MODULE_1__sjcl_custom_js___default.a.hash[HMAC_ALGORITHMS[algorithm]];\n\t\t\tconst fromBits = __WEBPACK_IMPORTED_MODULE_1__sjcl_custom_js___default.a.codec.arrayBuffer.fromBits;\n\t\t\tconst toBits = __WEBPACK_IMPORTED_MODULE_1__sjcl_custom_js___default.a.codec.arrayBuffer.toBits;\n\n\t\t\tconst hmac = new __WEBPACK_IMPORTED_MODULE_1__sjcl_custom_js___default.a.misc.hmac(toBits(key), hash);\n\t\t\thmac.update(toBits(message));\n\n\t\t\tdigest = fromBits(hmac.digest(), false);\n\t\t} else {\n\t\t\tthrow Error('Unable to create HMAC digest');\n\t\t}\n\n\t\treturn digest;\n\t}\n}\n/* harmony export (immutable) */ exports[\"a\"] = HMAC;\n\n\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Secret_js__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__HMAC_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__URI_js__ = __webpack_require__(4);\n\n\n\n\n\n\n\n/**\n * Default Configuration.\n * @private\n */\nconst DC = {\n\t'issuer': '',        // HOTP/TOTP\n\t'label': 'OTPAuth',  // HOTP/TOTP\n\t'algorithm': 'SHA1', // HOTP/TOTP\n\t'digits': 6,         // HOTP/TOTP\n\t'counter': 0,        // HOTP\n\t'period': 30,        // TOTP\n\t'window': 50,        // HOTP/TOTP\n\t'pad': true          // HOTP/TOTP\n};\n\n/**\n * @class HOTP\n */\nclass HOTP {\n\t/**\n\t * HOTP: An HMAC-based One-time Password Algorithm (RFC 4226)\n\t * @see https://tools.ietf.org/html/rfc4226\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer] Account provider.\n\t * @param {string} [config.label=OTPAuth] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Initial counter value.\n\t */\n\tconstructor({issuer = DC.issuer, label = DC.label, secret = new __WEBPACK_IMPORTED_MODULE_1__Secret_js__[\"a\" /* Secret */](), algorithm = DC.algorithm, digits = DC.digits, counter = DC.counter} = {}) {\n\t\t/** @type {string} */\n\t\tthis.issuer = issuer;\n\t\t/** @type {string} */\n\t\tthis.label = label;\n\t\t/** @type {string} */\n\t\tthis.algorithm = algorithm;\n\t\t/** @type {Secret} */\n\t\tthis.secret = secret;\n\t\t/** @type {number} */\n\t\tthis.digits = digits;\n\t\t/** @type {number} */\n\t\tthis.counter = counter;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @method generate\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({secret, algorithm = DC.algorithm, digits = DC.digits, counter = DC.counter, pad = DC.pad}) {\n\t\tconst digest = new Uint8Array(__WEBPACK_IMPORTED_MODULE_2__HMAC_js__[\"a\" /* HMAC */].digest({\n\t\t\t'algorithm': algorithm,\n\t\t\t'key': secret.buffer,\n\t\t\t'message': __WEBPACK_IMPORTED_MODULE_0__Utils_js__[\"a\" /* Utils */].uint.encode(counter)\n\t\t}));\n\n\t\tconst offset = digest[digest.byteLength - 1] & 15;\n\t\tconst binary = (\n\t\t\t(digest[offset] & 127) << 24 |\n\t\t\t(digest[offset + 1] & 255) << 16 |\n\t\t\t(digest[offset + 2] & 255) << 8 |\n\t\t\t(digest[offset + 3] & 255)\n\t\t) % Math.pow(10, digits);\n\n\t\treturn pad\n\t\t\t// ? '0'.repeat(digits - String(binary).length) + binary\n\t\t\t? Array(1 + digits - String(binary).length).join('0') + binary\n\t\t\t: binary;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @method generate\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.counter=this.counter++] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({counter = this.counter++, pad} = {}) {\n\t\treturn HOTP.generate({\n\t\t\t'secret': this.secret,\n\t\t\t'algorithm': this.algorithm,\n\t\t\t'digits': this.digits,\n\t\t\t'counter': counter,\n\t\t\t'pad': pad\n\t\t});\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @method validate\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({token, secret, algorithm, counter = DC.counter, window = DC.window}) {\n\t\tconst searchToken = parseInt(token, 10);\n\n\t\tfor (let i = counter - window; i <= counter + window; ++i) {\n\t\t\tconst generatedToken = HOTP.generate({\n\t\t\t\t'secret': secret,\n\t\t\t\t'algorithm': algorithm,\n\t\t\t\t'counter': i,\n\t\t\t\t'digits': token.length,\n\t\t\t\t'pad': false\n\t\t\t});\n\n\t\t\tif (searchToken === generatedToken) {\n\t\t\t\treturn i - counter;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @method validate\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.counter=this.counter] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({token, counter = this.counter, window}) {\n\t\treturn HOTP.validate({\n\t\t\t'token': token,\n\t\t\t'secret': this.secret,\n\t\t\t'algorithm': this.algorithm,\n\t\t\t'counter': counter,\n\t\t\t'window': window\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @method toString\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn __WEBPACK_IMPORTED_MODULE_3__URI_js__[\"a\" /* URI */].stringify(this);\n\t}\n}\n/* harmony export (immutable) */ exports[\"a\"] = HOTP;\n\n\n/**\n * @class TOTP\n */\nclass TOTP {\n\t/**\n\t * TOTP: Time-Based One-Time Password Algorithm (RFC 6238).\n\t * @see https://tools.ietf.org/html/rfc6238\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer] Account provider.\n\t * @param {string} [config.label=OTPAuth] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t */\n\tconstructor({issuer = DC.issuer, label = DC.label, secret = new __WEBPACK_IMPORTED_MODULE_1__Secret_js__[\"a\" /* Secret */](), algorithm = DC.algorithm, digits = DC.digits, period = DC.period} = {}) {\n\t\t/** @type {string} */\n\t\tthis.issuer = issuer;\n\t\t/** @type {string} */\n\t\tthis.label = label;\n\t\t/** @type {string} */\n\t\tthis.secret = secret;\n\t\t/** @type {Secret} */\n\t\tthis.algorithm = algorithm;\n\t\t/** @type {number} */\n\t\tthis.digits = digits;\n\t\t/** @type {number} */\n\t\tthis.period = period;\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @method generate\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({secret, algorithm, digits, period = DC.period, timestamp = Date.now(), pad}) {\n\t\treturn HOTP.generate({\n\t\t\t'secret': secret,\n\t\t\t'algorithm': algorithm,\n\t\t\t'digits': digits,\n\t\t\t'counter': Math.floor(timestamp / 1000 / period),\n\t\t\t'pad': pad\n\t\t});\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @method generate\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({timestamp = Date.now(), pad} = {}) {\n\t\treturn TOTP.generate({\n\t\t\t'secret': this.secret,\n\t\t\t'algorithm': this.algorithm,\n\t\t\t'digits': this.digits,\n\t\t\t'period': this.period,\n\t\t\t'timestamp': timestamp,\n\t\t\t'pad': pad\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @method validate\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({token, secret, algorithm, period = DC.period, timestamp = Date.now(), window}) {\n\t\treturn HOTP.validate({\n\t\t\t'token': token,\n\t\t\t'secret': secret,\n\t\t\t'algorithm': algorithm,\n\t\t\t'counter': Math.floor(timestamp / 1000 / period),\n\t\t\t'window': window\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @method validate\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({token, timestamp, window}) {\n\t\treturn TOTP.validate({\n\t\t\t'token': token,\n\t\t\t'secret': this.secret,\n\t\t\t'algorithm': this.algorithm,\n\t\t\t'period': this.period,\n\t\t\t'timestamp': timestamp,\n\t\t\t'window': window\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @method toString\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn __WEBPACK_IMPORTED_MODULE_3__URI_js__[\"a\" /* URI */].stringify(this);\n\t}\n}\n/* harmony export (immutable) */ exports[\"b\"] = TOTP;\n\n\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Secret_js__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__OTP_js__ = __webpack_require__(3);\n\n\n\n\n\n\n/*\n * Google Authenticator key URI format:\n *   https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\n\n// otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\nconst OTPURI_PARAMS = ['issuer', 'label', 'secret', 'algorithm', 'digits', 'counter', 'period'].join('|');\nconst OTPURI_REGEX = RegExp(`^otpauth:\\\\/\\\\/([ht]otp)\\\\/(.+)\\\\?((?:&?(?:${OTPURI_PARAMS})+=[^&]+)+)$`, 'i');\n\n// RFC 4648 base32 alphabet without pad\nconst SECRET_REGEX = /^[2-7A-Z]+$/i;\n\n// Support all algorithms defined in HMAC class\nconst ALGORITHM_REGEX = /SHA(?:1|256|512)/i;\n\n// Integer\nconst INTEGER_REGEX = /^[+-]?[0-9]+$/;\n\n// Positive integer, excluding 0\nconst POSITIVE_INTEGER_REGEX = /^\\+?[1-9][0-9]*$/;\n\n/**\n * @class URI\n */\nclass URI {\n\t/**\n\t * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n\t * @method parse\n\t * @param {string} uri Google Authenticator Key URI.\n\t * @returns {Object} HOTP/TOTP object.\n\t */\n\tstatic parse(uri) {\n\t\tconst uriGroups = decodeURIComponent(uri).match(OTPURI_REGEX);\n\n\t\tif (uriGroups === null) {\n\t\t\tthrow Error('Invalid URI format');\n\t\t}\n\n\t\t// Extract URI groups\n\t\tconst uriType = uriGroups[1].toLowerCase();\n\t\tconst uriLabel = uriGroups[2].split(/:(.+)/, 2);\n\t\tconst uriParams = uriGroups[3].split('&').reduce(function(acc, cur) {\n\t\t\tconst pairArr = cur.split(/=(.+)/, 2);\n\t\t\tconst pairKey = pairArr[0].toLowerCase();\n\t\t\tconst pairVal = pairArr[1];\n\t\t\tconst pairAcc = acc;\n\n\t\t\tpairAcc[pairKey] = pairVal;\n\t\t\treturn pairAcc;\n\t\t}, {});\n\n\t\t// 'otpObj' will be instantiated with 'otpCfg' argument\n\t\tlet otpObj, otpCfg = {};\n\n\t\tif (uriType === 'hotp') {\n\t\t\totpObj = __WEBPACK_IMPORTED_MODULE_2__OTP_js__[\"a\" /* HOTP */];\n\n\t\t\t// counter: required\n\t\t\tif (INTEGER_REGEX.test(uriParams.counter)) {\n\t\t\t\totpCfg.counter = parseInt(uriParams.counter, 10);\n\t\t\t} else {\n\t\t\t\tthrow Error('Missing or invalid \\'counter\\' parameter');\n\t\t\t}\n\t\t} else if (uriType === 'totp') {\n\t\t\totpObj = __WEBPACK_IMPORTED_MODULE_2__OTP_js__[\"b\" /* TOTP */];\n\n\t\t\t// period: optional\n\t\t\tif (typeof uriParams.period !== 'undefined' && uriType === 'totp') {\n\t\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n\t\t\t\t\totpCfg.period = parseInt(uriParams.period, 10);\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error('Invalid \\'period\\' parameter');\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow Error('Unknown OTP type');\n\t\t}\n\n\t\t// label: required\n\t\t// issuer: optional\n\t\tif (uriLabel.length === 2) {\n\t\t\totpCfg.label = uriLabel[1];\n\t\t\tif (typeof uriParams.issuer === 'undefined') {\n\t\t\t\totpCfg.issuer = uriLabel[0];\n\t\t\t} else if (uriParams.issuer === uriLabel[0]) {\n\t\t\t\totpCfg.issuer = uriParams.issuer;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid \\'issuer\\' parameter');\n\t\t\t}\n\t\t} else {\n\t\t\totpCfg.label = uriLabel[0];\n\t\t\tif (typeof uriParams.issuer !== 'undefined') {\n\t\t\t\totpCfg.issuer = uriParams.issuer;\n\t\t\t}\n\t\t}\n\n\t\t// secret: required\n\t\tif (SECRET_REGEX.test(uriParams.secret)) {\n\t\t\totpCfg.secret = new __WEBPACK_IMPORTED_MODULE_1__Secret_js__[\"a\" /* Secret */]({'buffer': __WEBPACK_IMPORTED_MODULE_0__Utils_js__[\"a\" /* Utils */].b32.encode(uriParams.secret)});\n\t\t} else {\n\t\t\tthrow Error('Missing or invalid \\'secret\\' parameter');\n\t\t}\n\n\t\t// algorithm: optional\n\t\tif (typeof uriParams.algorithm !== 'undefined') {\n\t\t\tif (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n\t\t\t\totpCfg.algorithm = uriParams.algorithm;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid \\'algorithm\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\t// digits: optional\n\t\tif (typeof uriParams.digits !== 'undefined') {\n\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n\t\t\t\totpCfg.digits = parseInt(uriParams.digits, 10);\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid \\'digits\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\treturn new otpObj(otpCfg);\n\t}\n\n\t/**\n\t * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n\t * @method stringify\n\t * @param {Object} otp HOTP/TOTP object.\n\t * @returns {string} Google Authenticator Key URI.\n\t */\n\tstatic stringify(otp) {\n\t\tif (!(otp instanceof __WEBPACK_IMPORTED_MODULE_2__OTP_js__[\"a\" /* HOTP */] || otp instanceof __WEBPACK_IMPORTED_MODULE_2__OTP_js__[\"b\" /* TOTP */])) {\n\t\t\tthrow Error('Invalid \\'HOTP/TOTP\\' object');\n\t\t}\n\n\t\treturn encodeURI('otpauth://'\n\t\t\t+ (otp instanceof __WEBPACK_IMPORTED_MODULE_2__OTP_js__[\"b\" /* TOTP */]\n\t\t\t\t? 'totp'\n\t\t\t\t: 'hotp')\n\n\t\t\t+ (otp.issuer.length > 0\n\t\t\t\t? `/${otp.issuer}:${otp.label}?issuer=${otp.issuer}&`\n\t\t\t\t: `/${otp.label}?`)\n\n\t\t\t+ `secret=${otp.secret.b32}`\n\t\t\t+ `&algorithm=${otp.algorithm}`\n\t\t\t+ `&digits=${otp.digits}`\n\n\t\t\t+ (otp instanceof __WEBPACK_IMPORTED_MODULE_2__OTP_js__[\"b\" /* TOTP */]\n\t\t\t\t? `&period=${otp.period}`\n\t\t\t\t: `&counter=${otp.counter}`)\n\t\t);\n\t}\n}\n/* harmony export (immutable) */ exports[\"a\"] = URI;\n\n\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/* === core/sjcl.js === */\n/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n\n/**\n * The Stanford Javascript Crypto Library, top-level namespace.\n * @namespace\n */\nvar sjcl = {\n  /**\n   * Symmetric ciphers.\n   * @namespace\n   */\n  cipher: {},\n\n  /**\n   * Hash functions.  Right now only SHA256 is implemented.\n   * @namespace\n   */\n  hash: {},\n\n  /**\n   * Key exchange functions.  Right now only SRP is implemented.\n   * @namespace\n   */\n  keyexchange: {},\n  \n  /**\n   * Cipher modes of operation.\n   * @namespace\n   */\n  mode: {},\n\n  /**\n   * Miscellaneous.  HMAC and PBKDF2.\n   * @namespace\n   */\n  misc: {},\n  \n  /**\n   * Bit array encoders and decoders.\n   * @namespace\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n  \n  /**\n   * Exceptions.\n   * @namespace\n   */\n  exception: {\n    /**\n     * Ciphertext is corrupt.\n     * @constructor\n     */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Invalid parameter.\n     * @constructor\n     */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Bug or missing feature in SJCL.\n     * @constructor\n     */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /**\n     * Something isn't ready.\n     * @constructor\n     */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n\n/* === core/bitArray.js === */\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} blength The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    \n    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n    \n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    \n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n  \n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  },\n\n  /** byteswap a word array inplace.\n   * (does not handle partial words)\n   * @param {sjcl.bitArray} a word array\n   * @return {sjcl.bitArray} byteswapped array\n   */\n  byteswapM: function(a) {\n    var i, v, m = 0xff00;\n    for (i = 0; i < a.length; ++i) {\n      v = a[i];\n      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);\n    }\n    return a;\n  }\n};\n\n/* === core/codecArrayBuffer.js === */\n/** @fileOverview Bit array codec implementations.\n *\n * @author Marco Munizaga\n */\n\n//patch arraybuffers if they don't exist\nif (typeof(ArrayBuffer) === 'undefined') {\n  (function(globals){\n      \"use strict\";\n      globals.ArrayBuffer = function(){};\n      globals.DataView = function(){};\n  }(this));\n}\n\n/**\n * ArrayBuffer\n * @namespace\n */\nsjcl.codec.arrayBuffer = {\n  /** Convert from a bitArray to an ArrayBuffer. \n   * Will default to 8byte padding if padding is undefined*/\n  fromBits: function (arr, padding, padding_count) {\n    var out, i, ol, tmp, smallest;\n    padding = padding==undefined  ? true : padding;\n    padding_count = padding_count || 8;\n\n    if (arr.length === 0) {\n      return new ArrayBuffer(0);\n    }\n\n    ol = sjcl.bitArray.bitLength(arr)/8;\n\n    //check to make sure the bitLength is divisible by 8, if it isn't \n    //we can't do anything since arraybuffers work with bytes, not bits\n    if ( sjcl.bitArray.bitLength(arr)%8 !== 0 ) {\n      throw new sjcl.exception.invalid(\"Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly\");\n    }\n\n    if (padding && ol%padding_count !== 0){\n      ol += padding_count - (ol%padding_count);\n    }\n\n\n    //padded temp for easy copying\n    tmp = new DataView(new ArrayBuffer(arr.length*4));\n    for (i=0; i<arr.length; i++) {\n      tmp.setUint32(i*4, (arr[i]<<32)); //get rid of the higher bits\n    }\n\n    //now copy the final message if we are not going to 0 pad\n    out = new DataView(new ArrayBuffer(ol));\n\n    //save a step when the tmp and out bytelength are ===\n    if (out.byteLength === tmp.byteLength){\n      return tmp.buffer;\n    }\n\n    smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;\n    for(i=0; i<smallest; i++){\n      out.setUint8(i,tmp.getUint8(i));\n    }\n\n\n    return out.buffer;\n  },\n\n  toBits: function (buffer) {\n    var i, out=[], len, inView, tmp;\n\n    if (buffer.byteLength === 0) {\n      return [];\n    }\n\n    inView = new DataView(buffer);\n    len = inView.byteLength - inView.byteLength%4;\n\n    for (var i = 0; i < len; i+=4) {\n      out.push(inView.getUint32(i));\n    }\n\n    if (inView.byteLength%4 != 0) {\n      tmp = new DataView(new ArrayBuffer(4));\n      for (var i = 0, l = inView.byteLength%4; i < l; i++) {\n        //we want the data to the right, because partial slices off the starting bits\n        tmp.setUint8(i+4-l, inView.getUint8(len+i)); // big-endian, \n      }\n      out.push(\n        sjcl.bitArray.partial( (inView.byteLength%4)*8, tmp.getUint32(0) )\n      ); \n    }\n    return out;\n  },\n\n\n\n  /** Prints a hex output of the buffer contents, akin to hexdump **/\n  hexDumpBuffer: function(buffer){\n      var stringBufferView = new DataView(buffer);\n      var string = '';\n      var pad = function (n, width) {\n          n = n + '';\n          return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n      };\n\n      for (var i = 0; i < stringBufferView.byteLength; i+=2) {\n          if (i%16 == 0) string += ('\\n'+(i).toString(16)+'\\t');\n          string += ( pad(stringBufferView.getUint16(i).toString(16),4) + ' ');\n      }\n\n      if ( typeof console === undefined ){\n        console = console || {log:function(){}}; //fix for IE\n      }\n      console.log(string.toUpperCase());\n  }\n};\n\n\n/* === core/sha1.js === */\n/** @fileOverview Javascript SHA-1 implementation.\n *\n * Based on the implementation in RFC 3174, method 1, and on the SJCL\n * SHA-256 implementation.\n *\n * @author Quinn Slack\n */\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n */\nsjcl.hash.sha1 = function (hash) {\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 5 big-endian words.\n */\nsjcl.hash.sha1.hash = function (data) {\n  return (new sjcl.hash.sha1()).update(data).finalize();\n};\n\nsjcl.hash.sha1.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n\t\ti+= this.blockSize) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n             i+= this.blockSize) {\n      \t     this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-1 initialization vector.\n   * @private\n   */\n  _init:[0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n\n  /**\n   * The SHA-1 hash key.\n   * @private\n   */\n  _key:[0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6],\n\n  /**\n   * The SHA-1 logical functions f(0), f(1), ..., f(79).\n   * @private\n   */\n  _f:function(t, b, c, d) {\n    if (t <= 19) {\n      return (b & c) | (~b & d);\n    } else if (t <= 39) {\n      return b ^ c ^ d;\n    } else if (t <= 59) {\n      return (b & c) | (b & d) | (c & d);\n    } else if (t <= 79) {\n      return b ^ c ^ d;\n    }\n  },\n\n  /**\n   * Circular left-shift operator.\n   * @private\n   */\n  _S:function(n, x) {\n    return (x << n) | (x >>> 32-n);\n  },\n  \n  /**\n   * Perform one cycle of SHA-1.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var t, tmp, a, b, c, d, e,\n    h = this._h;\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n        // When words is passed to _block, it has 16 elements. SHA1 _block\n        // function extends words with new elements (at the end there are 80 elements). \n        // The problem is that if we use Uint32Array instead of Array, \n        // the length of Uint32Array cannot be changed. Thus, we replace words with a \n        // normal Array here.\n        w = Array(80); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<16; j++){\n            w[j] = words[j];\n        }\n    } else {\n        w = words;\n    }\n\n    a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4]; \n\n    for (t=0; t<=79; t++) {\n      if (t >= 16) {\n        w[t] = this._S(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);\n      }\n      tmp = (this._S(5, a) + this._f(t, b, c, d) + e + w[t] +\n             this._key[Math.floor(t/20)]) | 0;\n      e = d;\n      d = c;\n      c = this._S(30, b);\n      b = a;\n      a = tmp;\n   }\n\n   h[0] = (h[0]+a) |0;\n   h[1] = (h[1]+b) |0;\n   h[2] = (h[2]+c) |0;\n   h[3] = (h[3]+d) |0;\n   h[4] = (h[4]+e) |0;\n  }\n};\n\n/* === core/sha256.js === */\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n\tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 8 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    \n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n    \n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n  \n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor, isPrime;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    for (; i<64; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i] = frac(Math.pow(prime, 1/2));\n        }\n        this._key[i] = frac(Math.pow(prime, 1/3));\n        i++;\n      }\n    }\n  },\n  \n  /**\n   * Perform one cycle of SHA-256.\n   * @param {Uint32Array|bitArray} w one block of words.\n   * @private\n   */\n  _block:function (w) {  \n    var i, tmp, a, b,\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + \n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n      \n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n      \n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n\n/* === core/sha512.js === */\n/** @fileOverview Javascript SHA-512 implementation.\n *\n * This implementation was written for CryptoJS by Jeff Mott and adapted for\n * SJCL by Stefan Thomas.\n *\n * CryptoJS (c) 20092012 by Jeff Mott. All rights reserved.\n * Released with New BSD License\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Jeff Mott\n * @author Stefan Thomas\n */\n\n/**\n * Context for a SHA-512 operation in progress.\n * @constructor\n */\nsjcl.hash.sha512 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha512.hash = function (data) {\n  return (new sjcl.hash.sha512()).update(data).finalize();\n};\n\nsjcl.hash.sha512.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 1024,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n        var c = new Uint32Array(b);\n        var j = 0;\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(c.subarray(32 * j, 32 * (j+1)));\n            j += 1;\n        }\n        b.splice(0, 32 * j);\n    } else {\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(b.splice(0,32));\n        }\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 16 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n\n    // Round out the buffer to a multiple of 32 words, less the 4 length words.\n    for (i = b.length + 4; i & 31; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(0);\n    b.push(0);\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,32));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-512 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n\n  /**\n   * Least significant 24 bits of SHA512 initialization values.\n   *\n   * Javascript only has 53 bits of precision, so we compute the 40 most\n   * significant bits and add the remaining 24 bits as constants.\n   *\n   * @private\n   */\n  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],\n\n  /*\n  _init:\n  [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n   0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179],\n  */\n\n  /**\n   * The SHA-512 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n\n  /**\n   * Least significant 24 bits of SHA512 key values.\n   * @private\n   */\n  _keyr:\n  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,\n   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,\n   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,\n   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,\n   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,\n   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,\n   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,\n   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,\n   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,\n   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],\n\n  /*\n  _key:\n  [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n   0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n   0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n   0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n   0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n   0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n   0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n   0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n   0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n   0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n   0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n   0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n   0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n   0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n   0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n   0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n   0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n   0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n   0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n   0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817],\n  */\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    // XXX: This code is for precomputing the SHA256 constants, change for\n    //      SHA512 and re-enable.\n    var i = 0, prime = 2, factor , isPrime;\n\n    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }\n    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }\n\n    for (; i<80; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i*2] = frac(Math.pow(prime, 1/2));\n          this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];\n        }\n        this._key[i*2] = frac(Math.pow(prime, 1/3));\n        this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];\n        i++;\n      }\n    }\n  },\n\n  /**\n   * Perform one cycle of SHA-512.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var i, wrh, wrl,\n        h = this._h,\n        k = this._key,\n        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],\n        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],\n        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],\n        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n\t// When words is passed to _block, it has 32 elements. SHA512 _block\n\t// function extends words with new elements (at the end there are 160 elements). \n\t// The problem is that if we use Uint32Array instead of Array, \n\t// the length of Uint32Array cannot be changed. Thus, we replace words with a \n\t// normal Array here.\n        w = Array(160); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<32; j++){\n    \t    w[j] = words[j]; \n        }\n    } else {\n\tw = words;\n    } \n\n    // Working variables\n    var ah = h0h, al = h0l, bh = h1h, bl = h1l,\n        ch = h2h, cl = h2l, dh = h3h, dl = h3l,\n        eh = h4h, el = h4l, fh = h5h, fl = h5l,\n        gh = h6h, gl = h6l, hh = h7h, hl = h7l;\n\n    for (i=0; i<80; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        wrh = w[i * 2];\n        wrl = w[i * 2 + 1];\n      } else {\n        // Gamma0\n        var gamma0xh = w[(i-15) * 2];\n        var gamma0xl = w[(i-15) * 2 + 1];\n        var gamma0h =\n          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^\n          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^\n           (gamma0xh >>> 7);\n        var gamma0l =\n          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^\n          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^\n          ((gamma0xh << 25) | (gamma0xl >>> 7));\n\n        // Gamma1\n        var gamma1xh = w[(i-2) * 2];\n        var gamma1xl = w[(i-2) * 2 + 1];\n        var gamma1h =\n          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^\n          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^\n           (gamma1xh >>> 6);\n        var gamma1l =\n          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^\n          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^\n          ((gamma1xh << 26) | (gamma1xl >>> 6));\n\n        // Shortcuts\n        var wr7h = w[(i-7) * 2];\n        var wr7l = w[(i-7) * 2 + 1];\n\n        var wr16h = w[(i-16) * 2];\n        var wr16l = w[(i-16) * 2 + 1];\n\n        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)\n        wrl = gamma0l + wr7l;\n        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n        wrl += gamma1l;\n        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n        wrl += wr16l;\n        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);\n      }\n\n      w[i*2]     = wrh |= 0;\n      w[i*2 + 1] = wrl |= 0;\n\n      // Ch\n      var chh = (eh & fh) ^ (~eh & gh);\n      var chl = (el & fl) ^ (~el & gl);\n\n      // Maj\n      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n      // Sigma0\n      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\n      // Sigma1\n      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));\n      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));\n\n      // K(round)\n      var krh = k[i*2];\n      var krl = k[i*2+1];\n\n      // t1 = h + sigma1 + ch + K(round) + W(round)\n      var t1l = hl + sigma1l;\n      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n      t1l += chl;\n      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n      t1l += krl;\n      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);\n      t1l = t1l + wrl|0;   // FF32..FF34 perf issue https://bugzilla.mozilla.org/show_bug.cgi?id=1054972\n      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);\n\n      // t2 = sigma0 + maj\n      var t2l = sigma0l + majl;\n      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n      // Update working variables\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = (dl + t1l) | 0;\n      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = (t1l + t2l) | 0;\n      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n    }\n\n    // Intermediate hash\n    h0l = h[1] = (h0l + al) | 0;\n    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;\n    h1l = h[3] = (h1l + bl) | 0;\n    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;\n    h2l = h[5] = (h2l + cl) | 0;\n    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;\n    h3l = h[7] = (h3l + dl) | 0;\n    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n    h4l = h[9] = (h4l + el) | 0;\n    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;\n    h5l = h[11] = (h5l + fl) | 0;\n    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;\n    h6l = h[13] = (h6l + gl) | 0;\n    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;\n    h7l = h[15] = (h7l + hl) | 0;\n    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;\n  }\n};\n\n\n\n/* === core/hmac.js === */\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n  \n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n  \n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n  this._resultHash = new Hash(this._baseHash[0]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  if (!this._updated) {\n    this.update(data);\n    return this.digest(data);\n  } else {\n    throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  }\n};\n\nsjcl.misc.hmac.prototype.reset = function () {\n  this._resultHash = new this._hash(this._baseHash[0]);\n  this._updated = false;\n};\n\nsjcl.misc.hmac.prototype.update = function (data) {\n  this._updated = true;\n  this._resultHash.update(data);\n};\n\nsjcl.misc.hmac.prototype.digest = function () {\n  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n\n  this.reset();\n\n  return result;\n};\n\n/* === core/exports.js === */\nif(typeof module !== 'undefined' && module.exports){\n  module.exports = sjcl;\n}\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n        return sjcl;\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"Utils\", function() { return __WEBPACK_IMPORTED_MODULE_0__Utils_js__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Secret_js__ = __webpack_require__(1);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"Secret\", function() { return __WEBPACK_IMPORTED_MODULE_1__Secret_js__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__HMAC_js__ = __webpack_require__(2);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"HMAC\", function() { return __WEBPACK_IMPORTED_MODULE_2__HMAC_js__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__OTP_js__ = __webpack_require__(3);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"HOTP\", function() { return __WEBPACK_IMPORTED_MODULE_3__OTP_js__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"TOTP\", function() { return __WEBPACK_IMPORTED_MODULE_3__OTP_js__[\"b\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__URI_js__ = __webpack_require__(4);\n/* harmony reexport (binding) */ __webpack_require__.d(exports, \"URI\", function() { return __WEBPACK_IMPORTED_MODULE_4__URI_js__[\"a\"]; });\n\n\n\n\n\n\n\n\n\n\n/***/ }\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// otpauth.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a3d1767cf7cd9b7840d2","'use strict';\n\n/**\n * @class Utils\n */\nexport class Utils {\n\t/**\n\t * @type {Object}\n\t */\n\tstatic get uint() {\n\t\t/**\n\t\t * Converts an ArrayBuffer to an integer.\n\t\t * @memberof Utils.uint\n\t\t * @method decode\n\t\t * @param {ArrayBuffer} buff ArrayBuffer.\n\t\t * @returns {number} Integer.\n\t\t */\n\t\tconst decode = function (buff) {\n\t\t\tconst tArr = new Uint8Array(buff);\n\t\t\tlet num = 0;\n\n\t\t\tfor (let i = 0; i < tArr.length; i++) {\n\t\t\t\tif (tArr[i] === 0) continue;\n\t\t\t\tnum *= 256;\n\t\t\t\tnum += tArr[i];\n\t\t\t}\n\n\t\t\treturn num;\n\t\t};\n\n\t\t/**\n\t\t * Converts an integer to an ArrayBuffer.\n\t\t * @memberof Utils.uint\n\t\t * @method encode\n\t\t * @param {string} num Integer.\n\t\t * @returns {ArrayBuffer} ArrayBuffer.\n\t\t */\n\t\tconst encode = function (num) {\n\t\t\tconst buff = new ArrayBuffer(8);\n\t\t\tconst tArr = new Uint8Array(buff);\n\t\t\tlet acc = num;\n\n\t\t\tfor (let i = 7; i >= 0; i--) {\n\t\t\t\tif (acc === 0) break;\n\t\t\t\ttArr[i] = acc & 255;\n\t\t\t\tacc -= tArr[i];\n\t\t\t\tacc /= 256;\n\t\t\t}\n\n\t\t\treturn buff;\n\t\t};\n\n\t\treturn {decode, encode};\n\t}\n\n\t/**\n\t * @type {Object}\n\t */\n\tstatic get raw() {\n\t\t/**\n\t\t * Converts an ArrayBuffer to a string.\n\t\t * @memberof Utils.raw\n\t\t * @method decode\n\t\t * @param {ArrayBuffer} buff ArrayBuffer.\n\t\t * @returns {string} String.\n\t\t */\n\t\tconst decode = function (buff) {\n\t\t\treturn String.fromCharCode.apply(null, new Uint8Array(buff));\n\t\t};\n\n\t\t/**\n\t\t * Converts a string to an ArrayBuffer.\n\t\t * @memberof Utils.raw\n\t\t * @method encode\n\t\t * @param {string} str String.\n\t\t * @returns {ArrayBuffer} ArrayBuffer.\n\t\t */\n\t\tconst encode = function (str) {\n\t\t\tconst buff = new ArrayBuffer(str.length);\n\t\t\tconst tArr = new Uint8Array(buff);\n\n\t\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\t\ttArr[i] = str.charCodeAt(i);\n\t\t\t}\n\n\t\t\treturn buff;\n\t\t};\n\n\t\treturn {decode, encode};\n\t}\n\n\t/**\n\t * @type {Object}\n\t */\n\tstatic get b32() {\n\t\t// RFC 4648 base32 alphabet without pad\n\t\tconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';\n\n\t\t/**\n\t\t * Converts an ArrayBuffer to a base32 string (RFC 4648).\n\t\t * @see https://tools.ietf.org/html/rfc4648\n\t\t * @see https://github.com/LinusU/base32-decode\n\t\t * @memberof Utils.b32\n\t\t * @method decode\n\t\t * @param {ArrayBuffer} buff ArrayBuffer.\n\t\t * @returns {string} Base32 string.\n\t\t */\n\t\tconst decode = function (buff) {\n\t\t\t// Based on LinusU/base32-decode\n\t\t\tconst tArr = new Uint8Array(buff);\n\t\t\tlet bits = 0, value = 0, str = '';\n\n\t\t\tfor (let i = 0; i < tArr.length; i++) {\n\t\t\t\tvalue = value << 8 | tArr[i];\n\t\t\t\tbits += 8;\n\n\t\t\t\twhile (bits >= 5) {\n\t\t\t\t\tstr += alphabet[value >>> bits - 5 & 31];\n\t\t\t\t\tbits -= 5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bits > 0) {\n\t\t\t\tstr += alphabet[value << 5 - bits & 31];\n\t\t\t}\n\n\t\t\treturn str;\n\t\t};\n\n\t\t/**\n\t\t * Converts a base32 string to an ArrayBuffer (RFC 4648).\n\t\t * @see https://tools.ietf.org/html/rfc4648\n\t\t * @see https://github.com/LinusU/base32-encode\n\t\t * @memberof Utils.b32\n\t\t * @method encode\n\t\t * @param {string} str Base32 String.\n\t\t * @returns {ArrayBuffer} ArrayBuffer.\n\t\t */\n\t\tconst encode = function (str) {\n\t\t\t// Based on LinusU/base32-encode\n\t\t\tconst strU = str.toUpperCase();\n\t\t\tconst buff = new ArrayBuffer(str.length * 5 / 8 | 0);\n\t\t\tconst tArr = new Uint8Array(buff);\n\t\t\tlet bits = 0, value = 0, index = 0;\n\n\t\t\tfor (let i = 0; i < strU.length; i++) {\n\t\t\t\tlet idx = alphabet.indexOf(strU[i]);\n\n\t\t\t\tif (idx === -1) {\n\t\t\t\t\tthrow new Error('Invalid character found: ' + strU[i]);\n\t\t\t\t}\n\n\t\t\t\tvalue = value << 5 | idx;\n\t\t\t\tbits += 5;\n\n\t\t\t\tif (bits >= 8) {\n\t\t\t\t\ttArr[index++] = value >>> bits - 8 & 255;\n\t\t\t\t\tbits -= 8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn buff;\n\t\t};\n\n\t\treturn {decode, encode};\n\t}\n\n\t/**\n\t * @type {Object}\n\t */\n\tstatic get hex() {\n\t\t/**\n\t\t * Converts an ArrayBuffer to a hexadecimal string.\n\t\t * @memberof Utils.hex\n\t\t * @method decode\n\t\t * @param {ArrayBuffer} buff ArrayBuffer.\n\t\t * @returns {string} Hexadecimal string.\n\t\t */\n\t\tconst decode = function (buff) {\n\t\t\tconst tArr = new Uint8Array(buff);\n\t\t\tlet str = '';\n\n\t\t\tfor (let i = 0; i < tArr.length; i++) {\n\t\t\t\tconst hexByte = tArr[i].toString(16);\n\n\t\t\t\tstr += hexByte.length === 1\n\t\t\t\t\t? '0' + hexByte\n\t\t\t\t\t: hexByte;\n\t\t\t}\n\n\t\t\treturn str.toUpperCase();\n\t\t};\n\n\t\t/**\n\t\t * Converts a hexadecimal string to an ArrayBuffer.\n\t\t * @memberof Utils.hex\n\t\t * @method encode\n\t\t * @param {string} str Hexadecimal string.\n\t\t * @returns {ArrayBuffer} ArrayBuffer.\n\t\t */\n\t\tconst encode = function (str) {\n\t\t\tconst buff = new ArrayBuffer(str.length / 2);\n\t\t\tconst tArr = new Uint8Array(buff);\n\n\t\t\tfor (let i = 0; i < tArr.length; i++) {\n\t\t\t\ttArr[i] = parseInt(str.substr(i * 2, 2), 16);\n\t\t\t}\n\n\t\t\treturn buff;\n\t\t};\n\n\t\treturn {decode, encode};\n\t}\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Utils.js\n// module id = 0\n// module chunks = 0","'use strict';\n\nimport {default as crypto} from 'crypto';\nimport {Utils} from './Utils.js';\n\n/**\n * @class Secret\n */\nexport class Secret {\n\t/**\n\t * Secret key object.\n\t * @param {Object} [config] Configuration options.\n\t * @param {ArrayBuffer} [config.buffer=Secret.getRandomBytes] ArrayBuffer of the secret key.\n\t */\n\tconstructor({buffer} = {}) {\n\t\t/** @type {ArrayBuffer} */\n\t\tthis.buffer = typeof buffer === 'undefined'\n\t\t\t? this.buffer = Secret.getRandomBytes()\n\t\t\t: buffer;\n\t\t/** @type {string} */\n\t\tthis.raw = Utils.raw.decode(this.buffer);\n\t\t/** @type {string} */\n\t\tthis.b32 = Utils.b32.decode(this.buffer);\n\t\t/** @type {string} */\n\t\tthis.hex = Utils.hex.decode(this.buffer);\n\t}\n\n\t/**\n\t * Returns an ArrayBuffer of random bytes using Node or Web Cryptography API.\n\t * @method getRandomBytes\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.size=20] Number of bytes to generate.\n\t * @returns {ArrayBuffer} Random bytes.\n\t */\n\tstatic getRandomBytes({size = 20} = {}) {\n\t\tlet bytes;\n\n\t\tif (typeof crypto !== 'undefined' && typeof crypto.randomBytes !== 'undefined') {\n\t\t\tbytes = new Uint8Array(crypto.randomBytes(size).buffer, 0, size);\n\t\t} else {\n\t\t\tbytes = new Uint8Array(size);\n\n\t\t\tif (typeof global.crypto !== 'undefined' && typeof global.crypto.getRandomValues !== 'undefined') {\n\t\t\t\tglobal.crypto.getRandomValues(bytes);\n\t\t\t} else if (typeof global.msCrypto !== 'undefined' && typeof global.msCrypto.getRandomValues !== 'undefined') {\n\t\t\t\tglobal.msCrypto.getRandomValues(bytes);\n\t\t\t} else { // WARNING: 'Math.random' is not cryptographically-secure\n\t\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\t\tbytes[i] = Math.floor(Math.random() * 256);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn bytes.buffer;\n\t}\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Secret.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nimport {default as crypto} from 'crypto';\nimport {default as sjcl} from './.sjcl.custom.js';\n\n/**\n * Supported HMAC algorithms.\n * The value of each key is used by the Stanford Javascript Crypto Library (SJCL).\n * @private\n */\nconst HMAC_ALGORITHMS = {\n\t'SHA1': 'sha1',\n\t'SHA256': 'sha256',\n\t'SHA512': 'sha512'\n};\n\n/**\n * @class HMAC\n */\nexport class HMAC {\n\t/**\n\t * Calculates the HMAC digest of the given key and message.\n\t * @method digest\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.algorithm Hashing algorithm (SHA1, SHA256 or SHA512).\n\t * @param {ArrayBuffer} config.key Key.\n\t * @param {ArrayBuffer} config.message Message.\n\t * @returns {ArrayBuffer} Digest.\n\t */\n\tstatic digest({algorithm, key, message}) {\n\t\tif (!(algorithm in HMAC_ALGORITHMS)) {\n\t\t\tthrow Error('Unknown hash function');\n\t\t}\n\n\t\tlet digest;\n\n\t\tif (typeof crypto !== 'undefined' && typeof crypto.createHmac !== 'undefined') {\n\t\t\tconst hmac = crypto.createHmac(algorithm, new Uint8Array(key));\n\t\t\thmac.update(new Uint8Array(message));\n\n\t\t\tdigest = hmac.digest();\n\t\t} else if (typeof sjcl !== 'undefined') {\n\t\t\tconst hash = sjcl.hash[HMAC_ALGORITHMS[algorithm]];\n\t\t\tconst fromBits = sjcl.codec.arrayBuffer.fromBits;\n\t\t\tconst toBits = sjcl.codec.arrayBuffer.toBits;\n\n\t\t\tconst hmac = new sjcl.misc.hmac(toBits(key), hash);\n\t\t\thmac.update(toBits(message));\n\n\t\t\tdigest = fromBits(hmac.digest(), false);\n\t\t} else {\n\t\t\tthrow Error('Unable to create HMAC digest');\n\t\t}\n\n\t\treturn digest;\n\t}\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HMAC.js\n// module id = 2\n// module chunks = 0","'use strict';\n\nimport {Utils} from './Utils.js';\nimport {Secret} from './Secret.js';\nimport {HMAC} from './HMAC.js';\nimport {URI} from './URI.js';\n\n/**\n * Default Configuration.\n * @private\n */\nconst DC = {\n\t'issuer': '',        // HOTP/TOTP\n\t'label': 'OTPAuth',  // HOTP/TOTP\n\t'algorithm': 'SHA1', // HOTP/TOTP\n\t'digits': 6,         // HOTP/TOTP\n\t'counter': 0,        // HOTP\n\t'period': 30,        // TOTP\n\t'window': 50,        // HOTP/TOTP\n\t'pad': true          // HOTP/TOTP\n};\n\n/**\n * @class HOTP\n */\nexport class HOTP {\n\t/**\n\t * HOTP: An HMAC-based One-time Password Algorithm (RFC 4226)\n\t * @see https://tools.ietf.org/html/rfc4226\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer] Account provider.\n\t * @param {string} [config.label=OTPAuth] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Initial counter value.\n\t */\n\tconstructor({issuer = DC.issuer, label = DC.label, secret = new Secret(), algorithm = DC.algorithm, digits = DC.digits, counter = DC.counter} = {}) {\n\t\t/** @type {string} */\n\t\tthis.issuer = issuer;\n\t\t/** @type {string} */\n\t\tthis.label = label;\n\t\t/** @type {string} */\n\t\tthis.algorithm = algorithm;\n\t\t/** @type {Secret} */\n\t\tthis.secret = secret;\n\t\t/** @type {number} */\n\t\tthis.digits = digits;\n\t\t/** @type {number} */\n\t\tthis.counter = counter;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @method generate\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({secret, algorithm = DC.algorithm, digits = DC.digits, counter = DC.counter, pad = DC.pad}) {\n\t\tconst digest = new Uint8Array(HMAC.digest({\n\t\t\t'algorithm': algorithm,\n\t\t\t'key': secret.buffer,\n\t\t\t'message': Utils.uint.encode(counter)\n\t\t}));\n\n\t\tconst offset = digest[digest.byteLength - 1] & 15;\n\t\tconst binary = (\n\t\t\t(digest[offset] & 127) << 24 |\n\t\t\t(digest[offset + 1] & 255) << 16 |\n\t\t\t(digest[offset + 2] & 255) << 8 |\n\t\t\t(digest[offset + 3] & 255)\n\t\t) % Math.pow(10, digits);\n\n\t\treturn pad\n\t\t\t// ? '0'.repeat(digits - String(binary).length) + binary\n\t\t\t? Array(1 + digits - String(binary).length).join('0') + binary\n\t\t\t: binary;\n\t}\n\n\t/**\n\t * Generates an HOTP token.\n\t * @method generate\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.counter=this.counter++] Counter value.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({counter = this.counter++, pad} = {}) {\n\t\treturn HOTP.generate({\n\t\t\t'secret': this.secret,\n\t\t\t'algorithm': this.algorithm,\n\t\t\t'digits': this.digits,\n\t\t\t'counter': counter,\n\t\t\t'pad': pad\n\t\t});\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @method validate\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.counter=0] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({token, secret, algorithm, counter = DC.counter, window = DC.window}) {\n\t\tconst searchToken = parseInt(token, 10);\n\n\t\tfor (let i = counter - window; i <= counter + window; ++i) {\n\t\t\tconst generatedToken = HOTP.generate({\n\t\t\t\t'secret': secret,\n\t\t\t\t'algorithm': algorithm,\n\t\t\t\t'counter': i,\n\t\t\t\t'digits': token.length,\n\t\t\t\t'pad': false\n\t\t\t});\n\n\t\t\tif (searchToken === generatedToken) {\n\t\t\t\treturn i - counter;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Validates an HOTP token.\n\t * @method validate\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.counter=this.counter] Counter value.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({token, counter = this.counter, window}) {\n\t\treturn HOTP.validate({\n\t\t\t'token': token,\n\t\t\t'secret': this.secret,\n\t\t\t'algorithm': this.algorithm,\n\t\t\t'counter': counter,\n\t\t\t'window': window\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @method toString\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn URI.stringify(this);\n\t}\n}\n\n/**\n * @class TOTP\n */\nexport class TOTP {\n\t/**\n\t * TOTP: Time-Based One-Time Password Algorithm (RFC 6238).\n\t * @see https://tools.ietf.org/html/rfc6238\n\t * @param {Object} [config] Configuration options.\n\t * @param {string} [config.issuer] Account provider.\n\t * @param {string} [config.label=OTPAuth] Account label.\n\t * @param {Secret} [config.secret=Secret] Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t */\n\tconstructor({issuer = DC.issuer, label = DC.label, secret = new Secret(), algorithm = DC.algorithm, digits = DC.digits, period = DC.period} = {}) {\n\t\t/** @type {string} */\n\t\tthis.issuer = issuer;\n\t\t/** @type {string} */\n\t\tthis.label = label;\n\t\t/** @type {string} */\n\t\tthis.secret = secret;\n\t\t/** @type {Secret} */\n\t\tthis.algorithm = algorithm;\n\t\t/** @type {number} */\n\t\tthis.digits = digits;\n\t\t/** @type {number} */\n\t\tthis.period = period;\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @method generate\n\t * @param {Object} config Configuration options.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.digits=6] Token length.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tstatic generate({secret, algorithm, digits, period = DC.period, timestamp = Date.now(), pad}) {\n\t\treturn HOTP.generate({\n\t\t\t'secret': secret,\n\t\t\t'algorithm': algorithm,\n\t\t\t'digits': digits,\n\t\t\t'counter': Math.floor(timestamp / 1000 / period),\n\t\t\t'pad': pad\n\t\t});\n\t}\n\n\t/**\n\t * Generates a TOTP token.\n\t * @method generate\n\t * @param {Object} [config] Configuration options.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {boolean} [config.pad=true] Add leading zeros to result.\n\t * @returns {string|number} Token.\n\t */\n\tgenerate({timestamp = Date.now(), pad} = {}) {\n\t\treturn TOTP.generate({\n\t\t\t'secret': this.secret,\n\t\t\t'algorithm': this.algorithm,\n\t\t\t'digits': this.digits,\n\t\t\t'period': this.period,\n\t\t\t'timestamp': timestamp,\n\t\t\t'pad': pad\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @method validate\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {Secret} config.secret Secret key.\n\t * @param {string} [config.algorithm=SHA1] HMAC hashing algorithm.\n\t * @param {number} [config.period=30] Token time-step duration.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tstatic validate({token, secret, algorithm, period = DC.period, timestamp = Date.now(), window}) {\n\t\treturn HOTP.validate({\n\t\t\t'token': token,\n\t\t\t'secret': secret,\n\t\t\t'algorithm': algorithm,\n\t\t\t'counter': Math.floor(timestamp / 1000 / period),\n\t\t\t'window': window\n\t\t});\n\t}\n\n\t/**\n\t * Validates a TOTP token.\n\t * @method validate\n\t * @param {Object} config Configuration options.\n\t * @param {string} config.token Token value.\n\t * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n\t * @param {number} [config.window=50] Window of counter values to test.\n\t * @returns {number|null} Token delta, or null if the token is not found.\n\t */\n\tvalidate({token, timestamp, window}) {\n\t\treturn TOTP.validate({\n\t\t\t'token': token,\n\t\t\t'secret': this.secret,\n\t\t\t'algorithm': this.algorithm,\n\t\t\t'period': this.period,\n\t\t\t'timestamp': timestamp,\n\t\t\t'window': window\n\t\t});\n\t}\n\n\t/**\n\t * Returns a Google Authenticator key URI.\n\t * @method toString\n\t * @returns {string} URI.\n\t */\n\ttoString() {\n\t\treturn URI.stringify(this);\n\t}\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/OTP.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nimport {Utils} from './Utils.js';\nimport {Secret} from './Secret.js';\nimport {HOTP, TOTP} from './OTP.js';\n\n/*\n * Google Authenticator key URI format:\n *   https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\n\n// otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS\nconst OTPURI_PARAMS = ['issuer', 'label', 'secret', 'algorithm', 'digits', 'counter', 'period'].join('|');\nconst OTPURI_REGEX = RegExp(`^otpauth:\\\\/\\\\/([ht]otp)\\\\/(.+)\\\\?((?:&?(?:${OTPURI_PARAMS})+=[^&]+)+)$`, 'i');\n\n// RFC 4648 base32 alphabet without pad\nconst SECRET_REGEX = /^[2-7A-Z]+$/i;\n\n// Support all algorithms defined in HMAC class\nconst ALGORITHM_REGEX = /SHA(?:1|256|512)/i;\n\n// Integer\nconst INTEGER_REGEX = /^[+-]?[0-9]+$/;\n\n// Positive integer, excluding 0\nconst POSITIVE_INTEGER_REGEX = /^\\+?[1-9][0-9]*$/;\n\n/**\n * @class URI\n */\nexport class URI {\n\t/**\n\t * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n\t * @method parse\n\t * @param {string} uri Google Authenticator Key URI.\n\t * @returns {Object} HOTP/TOTP object.\n\t */\n\tstatic parse(uri) {\n\t\tconst uriGroups = decodeURIComponent(uri).match(OTPURI_REGEX);\n\n\t\tif (uriGroups === null) {\n\t\t\tthrow Error('Invalid URI format');\n\t\t}\n\n\t\t// Extract URI groups\n\t\tconst uriType = uriGroups[1].toLowerCase();\n\t\tconst uriLabel = uriGroups[2].split(/:(.+)/, 2);\n\t\tconst uriParams = uriGroups[3].split('&').reduce(function(acc, cur) {\n\t\t\tconst pairArr = cur.split(/=(.+)/, 2);\n\t\t\tconst pairKey = pairArr[0].toLowerCase();\n\t\t\tconst pairVal = pairArr[1];\n\t\t\tconst pairAcc = acc;\n\n\t\t\tpairAcc[pairKey] = pairVal;\n\t\t\treturn pairAcc;\n\t\t}, {});\n\n\t\t// 'otpObj' will be instantiated with 'otpCfg' argument\n\t\tlet otpObj, otpCfg = {};\n\n\t\tif (uriType === 'hotp') {\n\t\t\totpObj = HOTP;\n\n\t\t\t// counter: required\n\t\t\tif (INTEGER_REGEX.test(uriParams.counter)) {\n\t\t\t\totpCfg.counter = parseInt(uriParams.counter, 10);\n\t\t\t} else {\n\t\t\t\tthrow Error('Missing or invalid \\'counter\\' parameter');\n\t\t\t}\n\t\t} else if (uriType === 'totp') {\n\t\t\totpObj = TOTP;\n\n\t\t\t// period: optional\n\t\t\tif (typeof uriParams.period !== 'undefined' && uriType === 'totp') {\n\t\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n\t\t\t\t\totpCfg.period = parseInt(uriParams.period, 10);\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error('Invalid \\'period\\' parameter');\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow Error('Unknown OTP type');\n\t\t}\n\n\t\t// label: required\n\t\t// issuer: optional\n\t\tif (uriLabel.length === 2) {\n\t\t\totpCfg.label = uriLabel[1];\n\t\t\tif (typeof uriParams.issuer === 'undefined') {\n\t\t\t\totpCfg.issuer = uriLabel[0];\n\t\t\t} else if (uriParams.issuer === uriLabel[0]) {\n\t\t\t\totpCfg.issuer = uriParams.issuer;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid \\'issuer\\' parameter');\n\t\t\t}\n\t\t} else {\n\t\t\totpCfg.label = uriLabel[0];\n\t\t\tif (typeof uriParams.issuer !== 'undefined') {\n\t\t\t\totpCfg.issuer = uriParams.issuer;\n\t\t\t}\n\t\t}\n\n\t\t// secret: required\n\t\tif (SECRET_REGEX.test(uriParams.secret)) {\n\t\t\totpCfg.secret = new Secret({'buffer': Utils.b32.encode(uriParams.secret)});\n\t\t} else {\n\t\t\tthrow Error('Missing or invalid \\'secret\\' parameter');\n\t\t}\n\n\t\t// algorithm: optional\n\t\tif (typeof uriParams.algorithm !== 'undefined') {\n\t\t\tif (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n\t\t\t\totpCfg.algorithm = uriParams.algorithm;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid \\'algorithm\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\t// digits: optional\n\t\tif (typeof uriParams.digits !== 'undefined') {\n\t\t\tif (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n\t\t\t\totpCfg.digits = parseInt(uriParams.digits, 10);\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid \\'digits\\' parameter');\n\t\t\t}\n\t\t}\n\n\t\treturn new otpObj(otpCfg);\n\t}\n\n\t/**\n\t * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n\t * @method stringify\n\t * @param {Object} otp HOTP/TOTP object.\n\t * @returns {string} Google Authenticator Key URI.\n\t */\n\tstatic stringify(otp) {\n\t\tif (!(otp instanceof HOTP || otp instanceof TOTP)) {\n\t\t\tthrow Error('Invalid \\'HOTP/TOTP\\' object');\n\t\t}\n\n\t\treturn encodeURI('otpauth://'\n\t\t\t+ (otp instanceof TOTP\n\t\t\t\t? 'totp'\n\t\t\t\t: 'hotp')\n\n\t\t\t+ (otp.issuer.length > 0\n\t\t\t\t? `/${otp.issuer}:${otp.label}?issuer=${otp.issuer}&`\n\t\t\t\t: `/${otp.label}?`)\n\n\t\t\t+ `secret=${otp.secret.b32}`\n\t\t\t+ `&algorithm=${otp.algorithm}`\n\t\t\t+ `&digits=${otp.digits}`\n\n\t\t\t+ (otp instanceof TOTP\n\t\t\t\t? `&period=${otp.period}`\n\t\t\t\t: `&counter=${otp.counter}`)\n\t\t);\n\t}\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/URI.js\n// module id = 4\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 5\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 6\n// module chunks = 0","\n/* === core/sjcl.js === */\n/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n\"use strict\";\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n\n/**\n * The Stanford Javascript Crypto Library, top-level namespace.\n * @namespace\n */\nvar sjcl = {\n  /**\n   * Symmetric ciphers.\n   * @namespace\n   */\n  cipher: {},\n\n  /**\n   * Hash functions.  Right now only SHA256 is implemented.\n   * @namespace\n   */\n  hash: {},\n\n  /**\n   * Key exchange functions.  Right now only SRP is implemented.\n   * @namespace\n   */\n  keyexchange: {},\n  \n  /**\n   * Cipher modes of operation.\n   * @namespace\n   */\n  mode: {},\n\n  /**\n   * Miscellaneous.  HMAC and PBKDF2.\n   * @namespace\n   */\n  misc: {},\n  \n  /**\n   * Bit array encoders and decoders.\n   * @namespace\n   *\n   * @description\n   * The members of this namespace are functions which translate between\n   * SJCL's bitArrays and other objects (usually strings).  Because it\n   * isn't always clear which direction is encoding and which is decoding,\n   * the method names are \"fromBits\" and \"toBits\".\n   */\n  codec: {},\n  \n  /**\n   * Exceptions.\n   * @namespace\n   */\n  exception: {\n    /**\n     * Ciphertext is corrupt.\n     * @constructor\n     */\n    corrupt: function(message) {\n      this.toString = function() { return \"CORRUPT: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Invalid parameter.\n     * @constructor\n     */\n    invalid: function(message) {\n      this.toString = function() { return \"INVALID: \"+this.message; };\n      this.message = message;\n    },\n    \n    /**\n     * Bug or missing feature in SJCL.\n     * @constructor\n     */\n    bug: function(message) {\n      this.toString = function() { return \"BUG: \"+this.message; };\n      this.message = message;\n    },\n\n    /**\n     * Something isn't ready.\n     * @constructor\n     */\n    notReady: function(message) {\n      this.toString = function() { return \"NOT READY: \"+this.message; };\n      this.message = message;\n    }\n  }\n};\n\n/* === core/bitArray.js === */\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n  /**\n   * Array slices in units of bits.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n   * slice until the end of the array.\n   * @return {bitArray} The requested slice.\n   */\n  bitSlice: function (a, bstart, bend) {\n    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);\n    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);\n  },\n\n  /**\n   * Extract a number packed into a bit array.\n   * @param {bitArray} a The array to slice.\n   * @param {Number} bstart The offset to the start of the slice, in bits.\n   * @param {Number} blength The length of the number to extract.\n   * @return {Number} The requested slice.\n   */\n  extract: function(a, bstart, blength) {\n    // FIXME: this Math.floor is not necessary at all, but for some reason\n    // seems to suppress a bug in the Chromium JIT.\n    var x, sh = Math.floor((-bstart-blength) & 31);\n    if ((bstart + blength - 1 ^ bstart) & -32) {\n      // it crosses a boundary\n      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);\n    } else {\n      // within a single word\n      x = a[bstart/32|0] >>> sh;\n    }\n    return x & ((1<<blength) - 1);\n  },\n\n  /**\n   * Concatenate two bit arrays.\n   * @param {bitArray} a1 The first array.\n   * @param {bitArray} a2 The second array.\n   * @return {bitArray} The concatenation of a1 and a2.\n   */\n  concat: function (a1, a2) {\n    if (a1.length === 0 || a2.length === 0) {\n      return a1.concat(a2);\n    }\n    \n    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);\n    if (shift === 32) {\n      return a1.concat(a2);\n    } else {\n      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));\n    }\n  },\n\n  /**\n   * Find the length of an array of bits.\n   * @param {bitArray} a The array.\n   * @return {Number} The length of a, in bits.\n   */\n  bitLength: function (a) {\n    var l = a.length, x;\n    if (l === 0) { return 0; }\n    x = a[l - 1];\n    return (l-1) * 32 + sjcl.bitArray.getPartial(x);\n  },\n\n  /**\n   * Truncate an array.\n   * @param {bitArray} a The array.\n   * @param {Number} len The length to truncate to, in bits.\n   * @return {bitArray} A new array, truncated to len bits.\n   */\n  clamp: function (a, len) {\n    if (a.length * 32 < len) { return a; }\n    a = a.slice(0, Math.ceil(len / 32));\n    var l = a.length;\n    len = len & 31;\n    if (l > 0 && len) {\n      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);\n    }\n    return a;\n  },\n\n  /**\n   * Make a partial word for a bit array.\n   * @param {Number} len The number of bits in the word.\n   * @param {Number} x The bits.\n   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n   * @return {Number} The partial word.\n   */\n  partial: function (len, x, _end) {\n    if (len === 32) { return x; }\n    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;\n  },\n\n  /**\n   * Get the number of bits used by a partial word.\n   * @param {Number} x The partial word.\n   * @return {Number} The number of bits used by the partial word.\n   */\n  getPartial: function (x) {\n    return Math.round(x/0x10000000000) || 32;\n  },\n\n  /**\n   * Compare two arrays for equality in a predictable amount of time.\n   * @param {bitArray} a The first array.\n   * @param {bitArray} b The second array.\n   * @return {boolean} true if a == b; false otherwise.\n   */\n  equal: function (a, b) {\n    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n      return false;\n    }\n    var x = 0, i;\n    for (i=0; i<a.length; i++) {\n      x |= a[i]^b[i];\n    }\n    return (x === 0);\n  },\n\n  /** Shift an array right.\n   * @param {bitArray} a The array to shift.\n   * @param {Number} shift The number of bits to shift.\n   * @param {Number} [carry=0] A byte to carry in\n   * @param {bitArray} [out=[]] An array to prepend to the output.\n   * @private\n   */\n  _shiftRight: function (a, shift, carry, out) {\n    var i, last2=0, shift2;\n    if (out === undefined) { out = []; }\n    \n    for (; shift >= 32; shift -= 32) {\n      out.push(carry);\n      carry = 0;\n    }\n    if (shift === 0) {\n      return out.concat(a);\n    }\n    \n    for (i=0; i<a.length; i++) {\n      out.push(carry | a[i]>>>shift);\n      carry = a[i] << (32-shift);\n    }\n    last2 = a.length ? a[a.length-1] : 0;\n    shift2 = sjcl.bitArray.getPartial(last2);\n    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));\n    return out;\n  },\n  \n  /** xor a block of 4 words together.\n   * @private\n   */\n  _xor4: function(x,y) {\n    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];\n  },\n\n  /** byteswap a word array inplace.\n   * (does not handle partial words)\n   * @param {sjcl.bitArray} a word array\n   * @return {sjcl.bitArray} byteswapped array\n   */\n  byteswapM: function(a) {\n    var i, v, m = 0xff00;\n    for (i = 0; i < a.length; ++i) {\n      v = a[i];\n      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);\n    }\n    return a;\n  }\n};\n\n/* === core/codecArrayBuffer.js === */\n/** @fileOverview Bit array codec implementations.\n *\n * @author Marco Munizaga\n */\n\n//patch arraybuffers if they don't exist\nif (typeof(ArrayBuffer) === 'undefined') {\n  (function(globals){\n      \"use strict\";\n      globals.ArrayBuffer = function(){};\n      globals.DataView = function(){};\n  }(this));\n}\n\n/**\n * ArrayBuffer\n * @namespace\n */\nsjcl.codec.arrayBuffer = {\n  /** Convert from a bitArray to an ArrayBuffer. \n   * Will default to 8byte padding if padding is undefined*/\n  fromBits: function (arr, padding, padding_count) {\n    var out, i, ol, tmp, smallest;\n    padding = padding==undefined  ? true : padding;\n    padding_count = padding_count || 8;\n\n    if (arr.length === 0) {\n      return new ArrayBuffer(0);\n    }\n\n    ol = sjcl.bitArray.bitLength(arr)/8;\n\n    //check to make sure the bitLength is divisible by 8, if it isn't \n    //we can't do anything since arraybuffers work with bytes, not bits\n    if ( sjcl.bitArray.bitLength(arr)%8 !== 0 ) {\n      throw new sjcl.exception.invalid(\"Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly\");\n    }\n\n    if (padding && ol%padding_count !== 0){\n      ol += padding_count - (ol%padding_count);\n    }\n\n\n    //padded temp for easy copying\n    tmp = new DataView(new ArrayBuffer(arr.length*4));\n    for (i=0; i<arr.length; i++) {\n      tmp.setUint32(i*4, (arr[i]<<32)); //get rid of the higher bits\n    }\n\n    //now copy the final message if we are not going to 0 pad\n    out = new DataView(new ArrayBuffer(ol));\n\n    //save a step when the tmp and out bytelength are ===\n    if (out.byteLength === tmp.byteLength){\n      return tmp.buffer;\n    }\n\n    smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;\n    for(i=0; i<smallest; i++){\n      out.setUint8(i,tmp.getUint8(i));\n    }\n\n\n    return out.buffer;\n  },\n\n  toBits: function (buffer) {\n    var i, out=[], len, inView, tmp;\n\n    if (buffer.byteLength === 0) {\n      return [];\n    }\n\n    inView = new DataView(buffer);\n    len = inView.byteLength - inView.byteLength%4;\n\n    for (var i = 0; i < len; i+=4) {\n      out.push(inView.getUint32(i));\n    }\n\n    if (inView.byteLength%4 != 0) {\n      tmp = new DataView(new ArrayBuffer(4));\n      for (var i = 0, l = inView.byteLength%4; i < l; i++) {\n        //we want the data to the right, because partial slices off the starting bits\n        tmp.setUint8(i+4-l, inView.getUint8(len+i)); // big-endian, \n      }\n      out.push(\n        sjcl.bitArray.partial( (inView.byteLength%4)*8, tmp.getUint32(0) )\n      ); \n    }\n    return out;\n  },\n\n\n\n  /** Prints a hex output of the buffer contents, akin to hexdump **/\n  hexDumpBuffer: function(buffer){\n      var stringBufferView = new DataView(buffer);\n      var string = '';\n      var pad = function (n, width) {\n          n = n + '';\n          return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n      };\n\n      for (var i = 0; i < stringBufferView.byteLength; i+=2) {\n          if (i%16 == 0) string += ('\\n'+(i).toString(16)+'\\t');\n          string += ( pad(stringBufferView.getUint16(i).toString(16),4) + ' ');\n      }\n\n      if ( typeof console === undefined ){\n        console = console || {log:function(){}}; //fix for IE\n      }\n      console.log(string.toUpperCase());\n  }\n};\n\n\n/* === core/sha1.js === */\n/** @fileOverview Javascript SHA-1 implementation.\n *\n * Based on the implementation in RFC 3174, method 1, and on the SJCL\n * SHA-256 implementation.\n *\n * @author Quinn Slack\n */\n\n/**\n * Context for a SHA-1 operation in progress.\n * @constructor\n */\nsjcl.hash.sha1 = function (hash) {\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 5 big-endian words.\n */\nsjcl.hash.sha1.hash = function (data) {\n  return (new sjcl.hash.sha1()).update(data).finalize();\n};\n\nsjcl.hash.sha1.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n\t\ti+= this.blockSize) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n    \tfor (i = this.blockSize+ol - ((this.blockSize+ol) & (this.blockSize-1)); i <= nl;\n             i+= this.blockSize) {\n      \t     this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-1 initialization vector.\n   * @private\n   */\n  _init:[0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0],\n\n  /**\n   * The SHA-1 hash key.\n   * @private\n   */\n  _key:[0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6],\n\n  /**\n   * The SHA-1 logical functions f(0), f(1), ..., f(79).\n   * @private\n   */\n  _f:function(t, b, c, d) {\n    if (t <= 19) {\n      return (b & c) | (~b & d);\n    } else if (t <= 39) {\n      return b ^ c ^ d;\n    } else if (t <= 59) {\n      return (b & c) | (b & d) | (c & d);\n    } else if (t <= 79) {\n      return b ^ c ^ d;\n    }\n  },\n\n  /**\n   * Circular left-shift operator.\n   * @private\n   */\n  _S:function(n, x) {\n    return (x << n) | (x >>> 32-n);\n  },\n  \n  /**\n   * Perform one cycle of SHA-1.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var t, tmp, a, b, c, d, e,\n    h = this._h;\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n        // When words is passed to _block, it has 16 elements. SHA1 _block\n        // function extends words with new elements (at the end there are 80 elements). \n        // The problem is that if we use Uint32Array instead of Array, \n        // the length of Uint32Array cannot be changed. Thus, we replace words with a \n        // normal Array here.\n        w = Array(80); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<16; j++){\n            w[j] = words[j];\n        }\n    } else {\n        w = words;\n    }\n\n    a = h[0]; b = h[1]; c = h[2]; d = h[3]; e = h[4]; \n\n    for (t=0; t<=79; t++) {\n      if (t >= 16) {\n        w[t] = this._S(1, w[t-3] ^ w[t-8] ^ w[t-14] ^ w[t-16]);\n      }\n      tmp = (this._S(5, a) + this._f(t, b, c, d) + e + w[t] +\n             this._key[Math.floor(t/20)]) | 0;\n      e = d;\n      d = c;\n      c = this._S(30, b);\n      b = a;\n      a = tmp;\n   }\n\n   h[0] = (h[0]+a) |0;\n   h[1] = (h[1]+b) |0;\n   h[2] = (h[2]+c) |0;\n   h[3] = (h[3]+d) |0;\n   h[4] = (h[4]+e) |0;\n  }\n};\n\n/* === core/sha256.js === */\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n */\nsjcl.hash.sha256 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n  return (new sjcl.hash.sha256()).update(data).finalize();\n};\n\nsjcl.hash.sha256.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 512,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n\tvar c = new Uint32Array(b);\n    \tvar j = 0;\n    \tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(c.subarray(16 * j, 16 * (j+1)));\n      \t    j += 1;\n    \t}\n    \tb.splice(0, 16 * j);\n    } else {\n\tfor (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {\n      \t    this._block(b.splice(0,16));\n      \t}\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 8 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n    \n    // Round out the buffer to a multiple of 16 words, less the 2 length words.\n    for (i = b.length + 2; i & 15; i++) {\n      b.push(0);\n    }\n    \n    // append the length\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,16));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-256 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n  /*\n  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n  */\n  \n  /**\n   * The SHA-256 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n  /*\n  _key:\n    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n  */\n\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    var i = 0, prime = 2, factor, isPrime;\n\n    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }\n\n    for (; i<64; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i] = frac(Math.pow(prime, 1/2));\n        }\n        this._key[i] = frac(Math.pow(prime, 1/3));\n        i++;\n      }\n    }\n  },\n  \n  /**\n   * Perform one cycle of SHA-256.\n   * @param {Uint32Array|bitArray} w one block of words.\n   * @private\n   */\n  _block:function (w) {  \n    var i, tmp, a, b,\n      h = this._h,\n      k = this._key,\n      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],\n      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n\n    /* Rationale for placement of |0 :\n     * If a value can overflow is original 32 bits by a factor of more than a few\n     * million (2^23 ish), there is a possibility that it might overflow the\n     * 53-bit mantissa and lose precision.\n     *\n     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n     * propagates around the loop, and on the hash state h[].  I don't believe\n     * that the clamps on h4 and on h0 are strictly necessary, but it's close\n     * (for h4 anyway), and better safe than sorry.\n     *\n     * The clamps on h[] are necessary for the output to be correct even in the\n     * common case and for short inputs.\n     */\n    for (i=0; i<64; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        tmp = w[i];\n      } else {\n        a   = w[(i+1 ) & 15];\n        b   = w[(i+14) & 15];\n        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + \n                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +\n                         w[i&15] + w[(i+9) & 15]) | 0;\n      }\n      \n      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;\n      \n      // shift register\n      h7 = h6; h6 = h5; h5 = h4;\n      h4 = h3 + tmp | 0;\n      h3 = h2; h2 = h1; h1 = h0;\n\n      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;\n    }\n\n    h[0] = h[0]+h0 | 0;\n    h[1] = h[1]+h1 | 0;\n    h[2] = h[2]+h2 | 0;\n    h[3] = h[3]+h3 | 0;\n    h[4] = h[4]+h4 | 0;\n    h[5] = h[5]+h5 | 0;\n    h[6] = h[6]+h6 | 0;\n    h[7] = h[7]+h7 | 0;\n  }\n};\n\n\n\n/* === core/sha512.js === */\n/** @fileOverview Javascript SHA-512 implementation.\n *\n * This implementation was written for CryptoJS by Jeff Mott and adapted for\n * SJCL by Stefan Thomas.\n *\n * CryptoJS (c) 20092012 by Jeff Mott. All rights reserved.\n * Released with New BSD License\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Jeff Mott\n * @author Stefan Thomas\n */\n\n/**\n * Context for a SHA-512 operation in progress.\n * @constructor\n */\nsjcl.hash.sha512 = function (hash) {\n  if (!this._key[0]) { this._precompute(); }\n  if (hash) {\n    this._h = hash._h.slice(0);\n    this._buffer = hash._buffer.slice(0);\n    this._length = hash._length;\n  } else {\n    this.reset();\n  }\n};\n\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha512.hash = function (data) {\n  return (new sjcl.hash.sha512()).update(data).finalize();\n};\n\nsjcl.hash.sha512.prototype = {\n  /**\n   * The hash's block size, in bits.\n   * @constant\n   */\n  blockSize: 1024,\n   \n  /**\n   * Reset the hash state.\n   * @return this\n   */\n  reset:function () {\n    this._h = this._init.slice(0);\n    this._buffer = [];\n    this._length = 0;\n    return this;\n  },\n  \n  /**\n   * Input several words to the hash.\n   * @param {bitArray|String} data the data to hash.\n   * @return this\n   */\n  update: function (data) {\n    if (typeof data === \"string\") {\n      data = sjcl.codec.utf8String.toBits(data);\n    }\n    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),\n        ol = this._length,\n        nl = this._length = ol + sjcl.bitArray.bitLength(data);\n    if (nl > 9007199254740991){\n      throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n    }\n\n    if (typeof Uint32Array !== 'undefined') {\n        var c = new Uint32Array(b);\n        var j = 0;\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(c.subarray(32 * j, 32 * (j+1)));\n            j += 1;\n        }\n        b.splice(0, 32 * j);\n    } else {\n        for (i = 1024+ol - ((1024+ol) & 1023); i <= nl; i+= 1024) {\n            this._block(b.splice(0,32));\n        }\n    }\n    return this;\n  },\n  \n  /**\n   * Complete hashing and output the hash value.\n   * @return {bitArray} The hash value, an array of 16 big-endian words.\n   */\n  finalize:function () {\n    var i, b = this._buffer, h = this._h;\n\n    // Round out and push the buffer\n    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);\n\n    // Round out the buffer to a multiple of 32 words, less the 4 length words.\n    for (i = b.length + 4; i & 31; i++) {\n      b.push(0);\n    }\n\n    // append the length\n    b.push(0);\n    b.push(0);\n    b.push(Math.floor(this._length / 0x100000000));\n    b.push(this._length | 0);\n\n    while (b.length) {\n      this._block(b.splice(0,32));\n    }\n\n    this.reset();\n    return h;\n  },\n\n  /**\n   * The SHA-512 initialization vector, to be precomputed.\n   * @private\n   */\n  _init:[],\n\n  /**\n   * Least significant 24 bits of SHA512 initialization values.\n   *\n   * Javascript only has 53 bits of precision, so we compute the 40 most\n   * significant bits and add the remaining 24 bits as constants.\n   *\n   * @private\n   */\n  _initr: [ 0xbcc908, 0xcaa73b, 0x94f82b, 0x1d36f1, 0xe682d1, 0x3e6c1f, 0x41bd6b, 0x7e2179 ],\n\n  /*\n  _init:\n  [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n   0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179],\n  */\n\n  /**\n   * The SHA-512 hash key, to be precomputed.\n   * @private\n   */\n  _key:[],\n\n  /**\n   * Least significant 24 bits of SHA512 key values.\n   * @private\n   */\n  _keyr:\n  [0x28ae22, 0xef65cd, 0x4d3b2f, 0x89dbbc, 0x48b538, 0x05d019, 0x194f9b, 0x6d8118,\n   0x030242, 0x706fbe, 0xe4b28c, 0xffb4e2, 0x7b896f, 0x1696b1, 0xc71235, 0x692694,\n   0xf14ad2, 0x4f25e3, 0x8cd5b5, 0xac9c65, 0x2b0275, 0xa6e483, 0x41fbd4, 0x1153b5,\n   0x66dfab, 0xb43210, 0xfb213f, 0xef0ee4, 0xa88fc2, 0x0aa725, 0x03826f, 0x0e6e70,\n   0xd22ffc, 0x26c926, 0xc42aed, 0x95b3df, 0xaf63de, 0x77b2a8, 0xedaee6, 0x82353b,\n   0xf10364, 0x423001, 0xf89791, 0x54be30, 0xef5218, 0x65a910, 0x71202a, 0xbbd1b8,\n   0xd2d0c8, 0x41ab53, 0x8eeb99, 0x9b48a8, 0xc95a63, 0x418acb, 0x63e373, 0xb2b8a3,\n   0xefb2fc, 0x172f60, 0xf0ab72, 0x6439ec, 0x631e28, 0x82bde9, 0xc67915, 0x72532b,\n   0x26619c, 0xc0c207, 0xe0eb1e, 0x6ed178, 0x176fba, 0xc898a6, 0xf90dae, 0x1c471b,\n   0x047d84, 0xc72493, 0xc9bebc, 0x100d4c, 0x3e42b6, 0x657e2a, 0xd6faec, 0x475817],\n\n  /*\n  _key:\n  [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n   0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n   0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n   0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n   0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n   0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n   0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n   0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n   0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n   0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n   0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n   0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n   0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n   0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n   0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n   0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n   0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n   0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n   0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n   0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817],\n  */\n\n  /**\n   * Function to precompute _init and _key.\n   * @private\n   */\n  _precompute: function () {\n    // XXX: This code is for precomputing the SHA256 constants, change for\n    //      SHA512 and re-enable.\n    var i = 0, prime = 2, factor , isPrime;\n\n    function frac(x)  { return (x-Math.floor(x)) * 0x100000000 | 0; }\n    function frac2(x) { return (x-Math.floor(x)) * 0x10000000000 & 0xff; }\n\n    for (; i<80; prime++) {\n      isPrime = true;\n      for (factor=2; factor*factor <= prime; factor++) {\n        if (prime % factor === 0) {\n          isPrime = false;\n          break;\n        }\n      }\n      if (isPrime) {\n        if (i<8) {\n          this._init[i*2] = frac(Math.pow(prime, 1/2));\n          this._init[i*2+1] = (frac2(Math.pow(prime, 1/2)) << 24) | this._initr[i];\n        }\n        this._key[i*2] = frac(Math.pow(prime, 1/3));\n        this._key[i*2+1] = (frac2(Math.pow(prime, 1/3)) << 24) | this._keyr[i];\n        i++;\n      }\n    }\n  },\n\n  /**\n   * Perform one cycle of SHA-512.\n   * @param {Uint32Array|bitArray} words one block of words.\n   * @private\n   */\n  _block:function (words) {\n    var i, wrh, wrl,\n        h = this._h,\n        k = this._key,\n        h0h = h[ 0], h0l = h[ 1], h1h = h[ 2], h1l = h[ 3],\n        h2h = h[ 4], h2l = h[ 5], h3h = h[ 6], h3l = h[ 7],\n        h4h = h[ 8], h4l = h[ 9], h5h = h[10], h5l = h[11],\n        h6h = h[12], h6l = h[13], h7h = h[14], h7l = h[15];\n    var w;\n    if (typeof Uint32Array !== 'undefined') {\n\t// When words is passed to _block, it has 32 elements. SHA512 _block\n\t// function extends words with new elements (at the end there are 160 elements). \n\t// The problem is that if we use Uint32Array instead of Array, \n\t// the length of Uint32Array cannot be changed. Thus, we replace words with a \n\t// normal Array here.\n        w = Array(160); // do not use Uint32Array here as the instantiation is slower\n        for (var j=0; j<32; j++){\n    \t    w[j] = words[j]; \n        }\n    } else {\n\tw = words;\n    } \n\n    // Working variables\n    var ah = h0h, al = h0l, bh = h1h, bl = h1l,\n        ch = h2h, cl = h2l, dh = h3h, dl = h3l,\n        eh = h4h, el = h4l, fh = h5h, fl = h5l,\n        gh = h6h, gl = h6l, hh = h7h, hl = h7l;\n\n    for (i=0; i<80; i++) {\n      // load up the input word for this round\n      if (i<16) {\n        wrh = w[i * 2];\n        wrl = w[i * 2 + 1];\n      } else {\n        // Gamma0\n        var gamma0xh = w[(i-15) * 2];\n        var gamma0xl = w[(i-15) * 2 + 1];\n        var gamma0h =\n          ((gamma0xl << 31) | (gamma0xh >>> 1)) ^\n          ((gamma0xl << 24) | (gamma0xh >>> 8)) ^\n           (gamma0xh >>> 7);\n        var gamma0l =\n          ((gamma0xh << 31) | (gamma0xl >>> 1)) ^\n          ((gamma0xh << 24) | (gamma0xl >>> 8)) ^\n          ((gamma0xh << 25) | (gamma0xl >>> 7));\n\n        // Gamma1\n        var gamma1xh = w[(i-2) * 2];\n        var gamma1xl = w[(i-2) * 2 + 1];\n        var gamma1h =\n          ((gamma1xl << 13) | (gamma1xh >>> 19)) ^\n          ((gamma1xh << 3)  | (gamma1xl >>> 29)) ^\n           (gamma1xh >>> 6);\n        var gamma1l =\n          ((gamma1xh << 13) | (gamma1xl >>> 19)) ^\n          ((gamma1xl << 3)  | (gamma1xh >>> 29)) ^\n          ((gamma1xh << 26) | (gamma1xl >>> 6));\n\n        // Shortcuts\n        var wr7h = w[(i-7) * 2];\n        var wr7l = w[(i-7) * 2 + 1];\n\n        var wr16h = w[(i-16) * 2];\n        var wr16l = w[(i-16) * 2 + 1];\n\n        // W(round) = gamma0 + W(round - 7) + gamma1 + W(round - 16)\n        wrl = gamma0l + wr7l;\n        wrh = gamma0h + wr7h + ((wrl >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n        wrl += gamma1l;\n        wrh += gamma1h + ((wrl >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n        wrl += wr16l;\n        wrh += wr16h + ((wrl >>> 0) < (wr16l >>> 0) ? 1 : 0);\n      }\n\n      w[i*2]     = wrh |= 0;\n      w[i*2 + 1] = wrl |= 0;\n\n      // Ch\n      var chh = (eh & fh) ^ (~eh & gh);\n      var chl = (el & fl) ^ (~el & gl);\n\n      // Maj\n      var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n      var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n      // Sigma0\n      var sigma0h = ((al << 4) | (ah >>> 28)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n      var sigma0l = ((ah << 4) | (al >>> 28)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\n      // Sigma1\n      var sigma1h = ((el << 18) | (eh >>> 14)) ^ ((el << 14) | (eh >>> 18)) ^ ((eh << 23) | (el >>> 9));\n      var sigma1l = ((eh << 18) | (el >>> 14)) ^ ((eh << 14) | (el >>> 18)) ^ ((el << 23) | (eh >>> 9));\n\n      // K(round)\n      var krh = k[i*2];\n      var krl = k[i*2+1];\n\n      // t1 = h + sigma1 + ch + K(round) + W(round)\n      var t1l = hl + sigma1l;\n      var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n      t1l += chl;\n      t1h += chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n      t1l += krl;\n      t1h += krh + ((t1l >>> 0) < (krl >>> 0) ? 1 : 0);\n      t1l = t1l + wrl|0;   // FF32..FF34 perf issue https://bugzilla.mozilla.org/show_bug.cgi?id=1054972\n      t1h += wrh + ((t1l >>> 0) < (wrl >>> 0) ? 1 : 0);\n\n      // t2 = sigma0 + maj\n      var t2l = sigma0l + majl;\n      var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n      // Update working variables\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = (dl + t1l) | 0;\n      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = (t1l + t2l) | 0;\n      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n    }\n\n    // Intermediate hash\n    h0l = h[1] = (h0l + al) | 0;\n    h[0] = (h0h + ah + ((h0l >>> 0) < (al >>> 0) ? 1 : 0)) | 0;\n    h1l = h[3] = (h1l + bl) | 0;\n    h[2] = (h1h + bh + ((h1l >>> 0) < (bl >>> 0) ? 1 : 0)) | 0;\n    h2l = h[5] = (h2l + cl) | 0;\n    h[4] = (h2h + ch + ((h2l >>> 0) < (cl >>> 0) ? 1 : 0)) | 0;\n    h3l = h[7] = (h3l + dl) | 0;\n    h[6] = (h3h + dh + ((h3l >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n    h4l = h[9] = (h4l + el) | 0;\n    h[8] = (h4h + eh + ((h4l >>> 0) < (el >>> 0) ? 1 : 0)) | 0;\n    h5l = h[11] = (h5l + fl) | 0;\n    h[10] = (h5h + fh + ((h5l >>> 0) < (fl >>> 0) ? 1 : 0)) | 0;\n    h6l = h[13] = (h6l + gl) | 0;\n    h[12] = (h6h + gh + ((h6l >>> 0) < (gl >>> 0) ? 1 : 0)) | 0;\n    h7l = h[15] = (h7l + hl) | 0;\n    h[14] = (h7h + hh + ((h7l >>> 0) < (hl >>> 0) ? 1 : 0)) | 0;\n  }\n};\n\n\n\n/* === core/hmac.js === */\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n  this._hash = Hash = Hash || sjcl.hash.sha256;\n  var exKey = [[],[]], i,\n      bs = Hash.prototype.blockSize / 32;\n  this._baseHash = [new Hash(), new Hash()];\n\n  if (key.length > bs) {\n    key = Hash.hash(key);\n  }\n  \n  for (i=0; i<bs; i++) {\n    exKey[0][i] = key[i]^0x36363636;\n    exKey[1][i] = key[i]^0x5C5C5C5C;\n  }\n  \n  this._baseHash[0].update(exKey[0]);\n  this._baseHash[1].update(exKey[1]);\n  this._resultHash = new Hash(this._baseHash[0]);\n};\n\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n  if (!this._updated) {\n    this.update(data);\n    return this.digest(data);\n  } else {\n    throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n  }\n};\n\nsjcl.misc.hmac.prototype.reset = function () {\n  this._resultHash = new this._hash(this._baseHash[0]);\n  this._updated = false;\n};\n\nsjcl.misc.hmac.prototype.update = function (data) {\n  this._updated = true;\n  this._resultHash.update(data);\n};\n\nsjcl.misc.hmac.prototype.digest = function () {\n  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n\n  this.reset();\n\n  return result;\n};\n\n/* === core/exports.js === */\nif(typeof module !== 'undefined' && module.exports){\n  module.exports = sjcl;\n}\nif (typeof define === \"function\") {\n    define([], function () {\n        return sjcl;\n    });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/.sjcl.custom.js\n// module id = 7\n// module chunks = 0"],"sourceRoot":""}