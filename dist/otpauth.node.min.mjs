/// <reference types="./otpauth.d.ts" />
import*as c from"node:crypto";const H=n=>{const e=new ArrayBuffer(8),r=new Uint8Array(e);let t=n;for(let s=7;s>=0&&t!==0;s--)r[s]=t&255,t-=r[s],t/=256;return e};var T=void 0;const d=(()=>{if(typeof globalThis=="object")return globalThis;Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:!0});try{if(typeof __GLOBALTHIS__!="undefined")return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}if(typeof self!="undefined")return self;if(typeof window!="undefined")return window;if(typeof global!="undefined")return global})(),U={SHA1:"SHA-1",SHA224:"SHA-224",SHA256:"SHA-256",SHA384:"SHA-384",SHA512:"SHA-512","SHA3-224":"SHA3-224","SHA3-256":"SHA3-256","SHA3-384":"SHA3-384","SHA3-512":"SHA3-512"},v=(n,e,r)=>{if(c!=null&&c.createHmac){const t=c.createHmac(n,d.Buffer.from(e));return t.update(d.Buffer.from(r)),t.digest().buffer}else{const t=U[n.toUpperCase()];if(typeof t=="undefined")throw new TypeError("Unknown hash function");const s=new T(t,"ARRAYBUFFER");return s.setHMACKey(e,"ARRAYBUFFER"),s.update(r),s.getHMAC("ARRAYBUFFER")}},m="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",E=n=>{let e=n.length;for(;n[e-1]==="=";)--e;const r=(e<n.length?n.substring(0,e):n).toUpperCase(),t=new ArrayBuffer(r.length*5/8|0),s=new Uint8Array(t);let i=0,a=0,o=0;for(let f=0;f<r.length;f++){const g=m.indexOf(r[f]);if(g===-1)throw new TypeError(`Invalid character found: ${r[f]}`);a=a<<5|g,i+=5,i>=8&&(i-=8,s[o++]=a>>>i)}return t},L=n=>{const e=new Uint8Array(n);let r=0,t=0,s="";for(let i=0;i<e.length;i++)for(t=t<<8|e[i],r+=8;r>=5;)s+=m[t>>>r-5&31],r-=5;return r>0&&(s+=m[t<<5-r&31]),s},B=n=>{const e=new ArrayBuffer(n.length/2),r=new Uint8Array(e);for(let t=0;t<n.length;t+=2)r[t/2]=parseInt(n.substring(t,t+2),16);return e},C=n=>{const e=new Uint8Array(n);let r="";for(let t=0;t<e.length;t++){const s=e[t].toString(16);s.length===1&&(r+="0"),r+=s}return r.toUpperCase()},O=n=>{const e=new ArrayBuffer(n.length),r=new Uint8Array(e);for(let t=0;t<n.length;t++)r[t]=n.charCodeAt(t)&255;return e},R=n=>{const e=new Uint8Array(n);let r="";for(let t=0;t<e.length;t++)r+=String.fromCharCode(e[t]);return r},y=d.TextEncoder?new d.TextEncoder("utf-8"):null,A=d.TextDecoder?new d.TextDecoder("utf-8"):null,P=n=>{if(!y)throw new Error("Encoding API not available");return y.encode(n).buffer},x=n=>{if(!A)throw new Error("Encoding API not available");return A.decode(n)},j=n=>{var e;if(c!=null&&c.randomBytes)return c.randomBytes(n).buffer;if(!((e=d.crypto)!=null&&e.getRandomValues))throw new Error("Cryptography API not available");return d.crypto.getRandomValues(new Uint8Array(n)).buffer};class h{constructor({buffer:e,size:r=20}={}){this.buffer=typeof e=="undefined"?j(r):e}static fromLatin1(e){return new h({buffer:O(e)})}static fromUTF8(e){return new h({buffer:P(e)})}static fromBase32(e){return new h({buffer:E(e)})}static fromHex(e){return new h({buffer:B(e)})}get latin1(){return Object.defineProperty(this,"latin1",{enumerable:!0,value:R(this.buffer)}),this.latin1}get utf8(){return Object.defineProperty(this,"utf8",{enumerable:!0,value:x(this.buffer)}),this.utf8}get base32(){return Object.defineProperty(this,"base32",{enumerable:!0,value:L(this.buffer)}),this.base32}get hex(){return Object.defineProperty(this,"hex",{enumerable:!0,value:C(this.buffer)}),this.hex}}const k=(n,e)=>{if(c!=null&&c.timingSafeEqual)return c.timingSafeEqual(d.Buffer.from(n),d.Buffer.from(e));{if(n.length!==e.length)throw new TypeError("Input strings must have the same length");let r=-1,t=0;for(;++r<n.length;)t|=n.charCodeAt(r)^e.charCodeAt(r);return t===0}};var F=Math.pow;let p=class l{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,counter:0,window:1}}constructor({issuer:e=l.defaults.issuer,label:r=l.defaults.label,issuerInLabel:t=l.defaults.issuerInLabel,secret:s=new h,algorithm:i=l.defaults.algorithm,digits:a=l.defaults.digits,counter:o=l.defaults.counter}={}){this.issuer=e,this.label=r,this.issuerInLabel=t,this.secret=typeof s=="string"?h.fromBase32(s):s,this.algorithm=i.toUpperCase(),this.digits=a,this.counter=o}static generate({secret:e,algorithm:r=l.defaults.algorithm,digits:t=l.defaults.digits,counter:s=l.defaults.counter}){const i=new Uint8Array(v(r,e.buffer,H(s))),a=i[i.byteLength-1]&15;return(((i[a]&127)<<24|(i[a+1]&255)<<16|(i[a+2]&255)<<8|i[a+3]&255)%F(10,t)).toString().padStart(t,"0")}generate({counter:e=this.counter++}={}){return l.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:e})}static validate({token:e,secret:r,algorithm:t,digits:s,counter:i=l.defaults.counter,window:a=l.defaults.window}){if(e.length!==s)return null;let o=null;for(let f=i-a;f<=i+a;++f){const g=l.generate({secret:r,algorithm:t,digits:s,counter:f});k(e,g)&&(o=f-i)}return o}validate({token:e,counter:r=this.counter,window:t}){return l.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:r,window:t})}toString(){const e=encodeURIComponent;return`otpauth://hotp/${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&counter=${e(this.counter)}`}};class u{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,period:30,window:1}}constructor({issuer:e=u.defaults.issuer,label:r=u.defaults.label,issuerInLabel:t=u.defaults.issuerInLabel,secret:s=new h,algorithm:i=u.defaults.algorithm,digits:a=u.defaults.digits,period:o=u.defaults.period}={}){this.issuer=e,this.label=r,this.issuerInLabel=t,this.secret=typeof s=="string"?h.fromBase32(s):s,this.algorithm=i.toUpperCase(),this.digits=a,this.period=o}static generate({secret:e,algorithm:r,digits:t,period:s=u.defaults.period,timestamp:i=Date.now()}){return p.generate({secret:e,algorithm:r,digits:t,counter:Math.floor(i/1e3/s)})}generate({timestamp:e=Date.now()}={}){return u.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:e})}static validate({token:e,secret:r,algorithm:t,digits:s,period:i=u.defaults.period,timestamp:a=Date.now(),window:o}){return p.validate({token:e,secret:r,algorithm:t,digits:s,counter:Math.floor(a/1e3/i),window:o})}validate({token:e,timestamp:r,window:t}){return u.validate({token:e,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:r,window:t})}toString(){const e=encodeURIComponent;return`otpauth://totp/${this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&period=${e(this.period)}`}}const M=/^otpauth:\/\/([ht]otp)\/(.+)\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i,D=/^[2-7A-Z]+=*$/i,G=/^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i,Y=/^[+-]?\d+$/,$=/^\+?[1-9]\d*$/;class Z{static parse(e){let r;try{r=e.match(M)}catch(f){}if(!Array.isArray(r))throw new URIError("Invalid URI format");const t=r[1].toLowerCase(),s=r[2].split(/(?::|%3A) *(.+)/i,2).map(decodeURIComponent),i=r[3].split("&").reduce((f,g)=>{const w=g.split(/=(.*)/,2).map(decodeURIComponent),I=w[0].toLowerCase(),S=w[1],b=f;return b[I]=S,b},{});let a;const o={};if(t==="hotp")if(a=p,typeof i.counter!="undefined"&&Y.test(i.counter))o.counter=parseInt(i.counter,10);else throw new TypeError("Missing or invalid 'counter' parameter");else if(t==="totp"){if(a=u,typeof i.period!="undefined")if($.test(i.period))o.period=parseInt(i.period,10);else throw new TypeError("Invalid 'period' parameter")}else throw new TypeError("Unknown OTP type");if(typeof i.issuer!="undefined"&&(o.issuer=i.issuer),s.length===2?(o.label=s[1],typeof o.issuer=="undefined"||o.issuer===""?o.issuer=s[0]:s[0]===""&&(o.issuerInLabel=!1)):(o.label=s[0],typeof o.issuer!="undefined"&&o.issuer!==""&&(o.issuerInLabel=!1)),typeof i.secret!="undefined"&&D.test(i.secret))o.secret=i.secret;else throw new TypeError("Missing or invalid 'secret' parameter");if(typeof i.algorithm!="undefined")if(G.test(i.algorithm))o.algorithm=i.algorithm;else throw new TypeError("Invalid 'algorithm' parameter");if(typeof i.digits!="undefined")if($.test(i.digits))o.digits=parseInt(i.digits,10);else throw new TypeError("Invalid 'digits' parameter");return new a(o)}static stringify(e){if(e instanceof p||e instanceof u)return e.toString();throw new TypeError("Invalid 'HOTP/TOTP' object")}}const V="9.2.3";export{p as HOTP,h as Secret,u as TOTP,Z as URI,V as version};
//# sourceMappingURL=otpauth.node.min.mjs.map
