/// <reference types="./otpauth.d.ts" />
"use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }); var H = require("crypto"); function T(i) { if (i && i.__esModule) return i; var e = Object.create(null); return i && Object.keys(i).forEach(function (r) { if (r !== "default") { var t = Object.getOwnPropertyDescriptor(i, r); Object.defineProperty(e, r, t.get ? t : { enumerable: !0, get: function () { return i[r] } }) } }), e.default = i, Object.freeze(e) } var g = T(H); const $ = i => { const e = new ArrayBuffer(8), r = new Uint8Array(e); let t = i; for (let n = 7; n >= 0 && t !== 0; n--)r[n] = t & 255, t -= r[n], t /= 256; return e }; var U = void 0; const d = (() => { if (typeof globalThis == "object") return globalThis; Object.defineProperty(Object.prototype, "__GLOBALTHIS__", { get() { return this }, configurable: !0 }); try { if (typeof __GLOBALTHIS__ != "undefined") return __GLOBALTHIS__ } finally { delete Object.prototype.__GLOBALTHIS__ } if (typeof self != "undefined") return self; if (typeof window != "undefined") return window; if (typeof global != "undefined") return global })(), I = { SHA1: "SHA-1", SHA224: "SHA-224", SHA256: "SHA-256", SHA384: "SHA-384", SHA512: "SHA-512", "SHA3-224": "SHA3-224", "SHA3-256": "SHA3-256", "SHA3-384": "SHA3-384", "SHA3-512": "SHA3-512" }, O = (i, e, r) => { if (g != null && g.createHmac) { const t = g.createHmac(i, d.Buffer.from(e)); return t.update(d.Buffer.from(r)), t.digest().buffer } else { const t = I[i.toUpperCase()]; if (typeof t == "undefined") throw new TypeError("Unknown hash function"); const n = new U(t, "ARRAYBUFFER"); return n.setHMACKey(e, "ARRAYBUFFER"), n.update(r), n.getHMAC("ARRAYBUFFER") } }, E = (i, e) => { let r = "", t = e - String(i).length; for (; t-- > 0;)r += "0"; return `${r}${i}` }, m = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", B = i => { let e = i.length; for (; i[e - 1] === "=";)--e; const r = (e < i.length ? i.substring(0, e) : i).toUpperCase(), t = new ArrayBuffer(r.length * 5 / 8 | 0), n = new Uint8Array(t); let s = 0, o = 0, a = 0; for (let u = 0; u < r.length; u++) { const h = m.indexOf(r[u]); if (h === -1) throw new TypeError(`Invalid character found: ${r[u]}`); o = o << 5 | h, s += 5, s >= 8 && (s -= 8, n[a++] = o >>> s) } return t }, C = i => { const e = new Uint8Array(i); let r = 0, t = 0, n = ""; for (let s = 0; s < e.length; s++)for (t = t << 8 | e[s], r += 8; r >= 5;)n += m[t >>> r - 5 & 31], r -= 5; return r > 0 && (n += m[t << 5 - r & 31]), n }, P = i => { const e = new ArrayBuffer(i.length / 2), r = new Uint8Array(e); for (let t = 0; t < i.length; t += 2)r[t / 2] = parseInt(i.substring(t, t + 2), 16); return e }, R = i => { const e = new Uint8Array(i); let r = ""; for (let t = 0; t < e.length; t++) { const n = e[t].toString(16); n.length === 1 && (r += "0"), r += n } return r.toUpperCase() }, j = i => { const e = new ArrayBuffer(i.length), r = new Uint8Array(e); for (let t = 0; t < i.length; t++)r[t] = i.charCodeAt(t) & 255; return e }, L = i => { const e = new Uint8Array(i); let r = ""; for (let t = 0; t < e.length; t++)r += String.fromCharCode(e[t]); return r }, y = d.TextEncoder ? new d.TextEncoder("utf-8") : null, b = d.TextDecoder ? new d.TextDecoder("utf-8") : null, M = i => { if (!y) throw new Error("Encoding API not available"); return y.encode(i).buffer }, x = i => { if (!b) throw new Error("Encoding API not available"); return b.decode(i) }, F = i => { if (g != null && g.randomBytes) return g.randomBytes(i).buffer; if (!d.crypto || !d.crypto.getRandomValues) throw new Error("Cryptography API not available"); return d.crypto.getRandomValues(new Uint8Array(i)).buffer }; class c { constructor() { let { buffer: e, size: r = 20 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; this.buffer = typeof e == "undefined" ? F(r) : e } static fromLatin1(e) { return new c({ buffer: j(e) }) } static fromUTF8(e) { return new c({ buffer: M(e) }) } static fromBase32(e) { return new c({ buffer: B(e) }) } static fromHex(e) { return new c({ buffer: P(e) }) } get latin1() { return Object.defineProperty(this, "latin1", { enumerable: !0, value: L(this.buffer) }), this.latin1 } get utf8() { return Object.defineProperty(this, "utf8", { enumerable: !0, value: x(this.buffer) }), this.utf8 } get base32() { return Object.defineProperty(this, "base32", { enumerable: !0, value: C(this.buffer) }), this.base32 } get hex() { return Object.defineProperty(this, "hex", { enumerable: !0, value: R(this.buffer) }), this.hex } } const k = (i, e) => { if (g != null && g.timingSafeEqual) return g.timingSafeEqual(d.Buffer.from(i), d.Buffer.from(e)); { if (i.length !== e.length) throw new TypeError("Input strings must have the same length"); let r = -1, t = 0; for (; ++r < i.length;)t |= i.charCodeAt(r) ^ e.charCodeAt(r); return t === 0 } }; var D = Math.pow; class l { static get defaults() { return { issuer: "", label: "OTPAuth", algorithm: "SHA1", digits: 6, counter: 0, window: 1 } } constructor() { let { issuer: e = l.defaults.issuer, label: r = l.defaults.label, secret: t = new c, algorithm: n = l.defaults.algorithm, digits: s = l.defaults.digits, counter: o = l.defaults.counter } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; this.issuer = e, this.label = r, this.secret = typeof t == "string" ? c.fromBase32(t) : t, this.algorithm = n.toUpperCase(), this.digits = s, this.counter = o } static generate(e) { let { secret: r, algorithm: t = l.defaults.algorithm, digits: n = l.defaults.digits, counter: s = l.defaults.counter } = e; const o = new Uint8Array(O(t, r.buffer, $(s))), a = o[o.byteLength - 1] & 15, u = ((o[a] & 127) << 24 | (o[a + 1] & 255) << 16 | (o[a + 2] & 255) << 8 | o[a + 3] & 255) % D(10, n); return E(u, n) } generate() { let { counter: e = this.counter++ } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; return l.generate({ secret: this.secret, algorithm: this.algorithm, digits: this.digits, counter: e }) } static validate(e) { let { token: r, secret: t, algorithm: n, digits: s, counter: o = l.defaults.counter, window: a = l.defaults.window } = e; if (r.length !== s) return null; let u = null; for (let h = o - a; h <= o + a; ++h) { const p = l.generate({ secret: t, algorithm: n, digits: s, counter: h }); k(r, p) && (u = h - o) } return u } validate(e) { let { token: r, counter: t = this.counter, window: n } = e; return l.validate({ token: r, secret: this.secret, algorithm: this.algorithm, digits: this.digits, counter: t, window: n }) } toString() { const e = encodeURIComponent; return `otpauth://hotp/${this.issuer.length > 0 ? `${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&counter=${e(this.counter)}` } } class f { static get defaults() { return { issuer: "", label: "OTPAuth", algorithm: "SHA1", digits: 6, period: 30, window: 1 } } constructor() { let { issuer: e = f.defaults.issuer, label: r = f.defaults.label, secret: t = new c, algorithm: n = f.defaults.algorithm, digits: s = f.defaults.digits, period: o = f.defaults.period } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; this.issuer = e, this.label = r, this.secret = typeof t == "string" ? c.fromBase32(t) : t, this.algorithm = n.toUpperCase(), this.digits = s, this.period = o } static generate(e) { let { secret: r, algorithm: t, digits: n, period: s = f.defaults.period, timestamp: o = Date.now() } = e; return l.generate({ secret: r, algorithm: t, digits: n, counter: Math.floor(o / 1e3 / s) }) } generate() { let { timestamp: e = Date.now() } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; return f.generate({ secret: this.secret, algorithm: this.algorithm, digits: this.digits, period: this.period, timestamp: e }) } static validate(e) { let { token: r, secret: t, algorithm: n, digits: s, period: o = f.defaults.period, timestamp: a = Date.now(), window: u } = e; return l.validate({ token: r, secret: t, algorithm: n, digits: s, counter: Math.floor(a / 1e3 / o), window: u }) } validate(e) { let { token: r, timestamp: t, window: n } = e; return f.validate({ token: r, secret: this.secret, algorithm: this.algorithm, digits: this.digits, period: this.period, timestamp: t, window: n }) } toString() { const e = encodeURIComponent; return `otpauth://totp/${this.issuer.length > 0 ? `${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?`}secret=${e(this.secret.base32)}&algorithm=${e(this.algorithm)}&digits=${e(this.digits)}&period=${e(this.period)}` } } const G = /^otpauth:\/\/([ht]otp)\/(.+)\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i, Y = /^[2-7A-Z]+=*$/i, Z = /^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i, q = /^[+-]?\d+$/, A = /^\+?[1-9]\d*$/; class V { static parse(e) { let r; try { r = e.match(G) } catch (u) { } if (!Array.isArray(r)) throw new URIError("Invalid URI format"); const t = r[1].toLowerCase(), n = r[2].split(/(?::|%3A) *(.+)/i, 2).map(decodeURIComponent), s = r[3].split("&").reduce((u, h) => { const p = h.split(/=(.*)/, 2).map(decodeURIComponent), v = p[0].toLowerCase(), S = p[1], w = u; return w[v] = S, w }, {}); let o; const a = {}; if (t === "hotp") if (o = l, typeof s.counter != "undefined" && q.test(s.counter)) a.counter = parseInt(s.counter, 10); else throw new TypeError("Missing or invalid 'counter' parameter"); else if (t === "totp") { if (o = f, typeof s.period != "undefined") if (A.test(s.period)) a.period = parseInt(s.period, 10); else throw new TypeError("Invalid 'period' parameter") } else throw new TypeError("Unknown OTP type"); if (n.length === 2 ? (a.label = n[1], a.issuer = n[0]) : (a.label = n[0], typeof s.issuer != "undefined" && (a.issuer = s.issuer)), typeof s.secret != "undefined" && Y.test(s.secret)) a.secret = s.secret; else throw new TypeError("Missing or invalid 'secret' parameter"); if (typeof s.algorithm != "undefined") if (Z.test(s.algorithm)) a.algorithm = s.algorithm; else throw new TypeError("Invalid 'algorithm' parameter"); if (typeof s.digits != "undefined") if (A.test(s.digits)) a.digits = parseInt(s.digits, 10); else throw new TypeError("Invalid 'digits' parameter"); return new o(a) } static stringify(e) { if (e instanceof l || e instanceof f) return e.toString(); throw new TypeError("Invalid 'HOTP/TOTP' object") } } const z = "9.0.1"; exports.HOTP = l, exports.Secret = c, exports.TOTP = f, exports.URI = V, exports.version = z;
//# sourceMappingURL=otpauth.node.min.cjs.map
